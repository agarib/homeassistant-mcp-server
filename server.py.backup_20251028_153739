#!/usr/bin/env python3
"""
ğŸ  Home Assistant MCP Server - Native Add-on Version (COMPLETE WITH 62 TOOLS!)
Running INSIDE Home Assistant with direct file system access

This version eliminates ALL SSH/SFTP complexity by running natively
inside Home Assistant as an add-on with direct access to:
- /config directory (mounted volume)
- Home Assistant API (via localhost/supervisor)
- No network issues, no authentication problems, 100% reliable

INCLUDES:
âœ… File Operations (9 tools)
âœ… Basic HA API (3 tools)
âœ… Device Discovery & Control (18 tools from Part 1)
âœ… Security, Automation, Workflows, Intelligence (35 tools from Part 2)
âœ… Dashboard & HACS Management (9 tools from Part 3)

TOTAL: 74 TOOLS for comprehensive Home Assistant control!
"""

import asyncio
import os
import json
import logging
import re
from pathlib import Path
from typing import Any, Dict, List, Optional
from datetime import datetime, timedelta
import aiofiles
from aiofiles import os as aio_os

import httpx
from mcp.server import Server
from mcp.server.stdio import stdio_server
from mcp.types import Tool, TextContent

# Configure logging
LOG_LEVEL = os.getenv("LOG_LEVEL", "info").upper()
logging.basicConfig(
    level=getattr(logging, LOG_LEVEL),
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)

# Configuration from environment
HA_URL = os.getenv("HA_URL", "http://supervisor/core/api")
HA_TOKEN = os.getenv("SUPERVISOR_TOKEN", "")
HA_CONFIG_PATH = Path(os.getenv("HA_CONFIG_PATH", "/config"))
PORT = int(os.getenv("PORT", "8001"))

logger.info(f"ğŸ  Home Assistant MCP Server (Native Add-on)")
logger.info(f"ğŸ“ Config Path: {HA_CONFIG_PATH}")
logger.info(f"ğŸŒ HA API URL: {HA_URL}")
logger.info(f"ğŸ”Œ Port: {PORT}")

# Create MCP server
app = Server("homeassistant-native")

# HTTP client for HA API
http_client = httpx.AsyncClient(
    timeout=30.0,
    headers={
        "Authorization": f"Bearer {HA_TOKEN}",
        "Content-Type": "application/json"
    } if HA_TOKEN else {"Content-Type": "application/json"}
)


class HomeAssistantAPI:
    """Direct access to Home Assistant API via localhost"""
    
    def __init__(self):
        self.base_url = HA_URL.rstrip('/')
        
    async def call_api(self, method: str, endpoint: str, data: Optional[Dict] = None) -> Any:
        """Make API call to Home Assistant"""
        url = f"{self.base_url}/{endpoint.lstrip('/')}"
        
        try:
            if method.upper() == "GET":
                response = await http_client.get(url)
            elif method.upper() == "POST":
                response = await http_client.post(url, json=data or {})
            else:
                raise ValueError(f"Unsupported method: {method}")
            
            response.raise_for_status()
            return response.json()
            
        except Exception as e:
            logger.error(f"API call failed: {e}")
            raise

    async def get_states(self) -> List[Dict]:
        """Get all entity states"""
        return await self.call_api("GET", "states")
    
    async def get_state(self, entity_id: str) -> Dict:
        """Get specific entity state"""
        return await self.call_api("GET", f"states/{entity_id}")
    
    async def call_service(self, domain: str, service: str, service_data: Optional[Dict] = None) -> Any:
        """Call a Home Assistant service"""
        return await self.call_api("POST", f"services/{domain}/{service}", service_data)


class FileManager:
    """Direct file system access - NO SSH/SFTP needed!"""
    
    def __init__(self, base_path: Path):
        self.base_path = base_path
        logger.info(f"âœ… FileManager initialized with direct access to: {base_path}")
    
    def _resolve_path(self, relative_path: str) -> Path:
        """Resolve relative path to absolute path within config"""
        # Remove leading slashes and normalize
        clean_path = relative_path.lstrip('/').replace('\\', '/')
        full_path = (self.base_path / clean_path).resolve()
        
        # Security check - ensure path is within config directory
        try:
            full_path.relative_to(self.base_path)
        except ValueError:
            raise PermissionError(f"Access denied: {relative_path} is outside config directory")
        
        return full_path
    
    async def read_file(self, filepath: str) -> str:
        """Read file content"""
        path = self._resolve_path(filepath)
        
        if not path.exists():
            raise FileNotFoundError(f"File not found: {filepath}")
        
        async with aiofiles.open(path, 'r', encoding='utf-8') as f:
            content = await f.read()
        
        logger.info(f"ğŸ“– Read file: {filepath} ({len(content)} bytes)")
        return content
    
    async def write_file(self, filepath: str, content: str, create_backup: bool = True) -> str:
        """Write file content with optional backup"""
        path = self._resolve_path(filepath)
        
        # Create parent directories if needed
        path.parent.mkdir(parents=True, exist_ok=True)
        
        # Create backup if file exists
        if create_backup and path.exists():
            backup_path = path.with_suffix(path.suffix + f'.bak_{datetime.now().strftime("%Y%m%d_%H%M%S")}')
            async with aiofiles.open(path, 'r', encoding='utf-8') as src:
                backup_content = await src.read()
            async with aiofiles.open(backup_path, 'w', encoding='utf-8') as dst:
                await dst.write(backup_content)
            logger.info(f"ğŸ’¾ Created backup: {backup_path.name}")
        
        # Write new content
        async with aiofiles.open(path, 'w', encoding='utf-8') as f:
            await f.write(content)
        
        logger.info(f"âœï¸  Wrote file: {filepath} ({len(content)} bytes)")
        return f"Successfully wrote {len(content)} bytes to {filepath}"
    
    async def list_directory(self, dirpath: str = ".") -> List[Dict[str, Any]]:
        """List directory contents"""
        path = self._resolve_path(dirpath)
        
        if not path.exists():
            raise FileNotFoundError(f"Directory not found: {dirpath}")
        
        if not path.is_dir():
            raise NotADirectoryError(f"Not a directory: {dirpath}")
        
        items = []
        for item in sorted(path.iterdir()):
            try:
                stat = item.stat()
                items.append({
                    "name": item.name,
                    "type": "directory" if item.is_dir() else "file",
                    "size": stat.st_size if item.is_file() else 0,
                    "modified": datetime.fromtimestamp(stat.st_mtime).isoformat()
                })
            except Exception as e:
                logger.warning(f"Could not stat {item}: {e}")
        
        logger.info(f"ğŸ“‹ Listed directory: {dirpath} ({len(items)} items)")
        return items
    
    async def get_directory_tree(self, dirpath: str = ".", max_depth: int = 5) -> Dict[str, Any]:
        """Get recursive directory tree"""
        path = self._resolve_path(dirpath)
        
        if not path.exists():
            raise FileNotFoundError(f"Directory not found: {dirpath}")
        
        def build_tree(current_path: Path, current_depth: int = 0) -> Dict:
            if current_depth >= max_depth:
                return {"truncated": True}
            
            tree = {
                "name": current_path.name or str(current_path),
                "type": "directory" if current_path.is_dir() else "file",
                "children": [] if current_path.is_dir() else None
            }
            
            if current_path.is_file():
                try:
                    tree["size"] = current_path.stat().st_size
                except:
                    pass
            elif current_path.is_dir():
                try:
                    for item in sorted(current_path.iterdir()):
                        tree["children"].append(build_tree(item, current_depth + 1))
                except PermissionError:
                    tree["error"] = "Permission denied"
            
            return tree
        
        tree = build_tree(path)
        logger.info(f"ğŸŒ³ Generated directory tree: {dirpath}")
        return tree
    
    async def create_directory(self, dirpath: str) -> str:
        """Create directory"""
        path = self._resolve_path(dirpath)
        path.mkdir(parents=True, exist_ok=True)
        logger.info(f"ğŸ“ Created directory: {dirpath}")
        return f"Created directory: {dirpath}"
    
    async def delete_file(self, filepath: str) -> str:
        """Delete file or directory"""
        path = self._resolve_path(filepath)
        
        if not path.exists():
            raise FileNotFoundError(f"Not found: {filepath}")
        
        if path.is_file():
            path.unlink()
            logger.info(f"ğŸ—‘ï¸  Deleted file: {filepath}")
            return f"Deleted file: {filepath}"
        elif path.is_dir():
            import shutil
            shutil.rmtree(path)
            logger.info(f"ğŸ—‘ï¸  Deleted directory: {filepath}")
            return f"Deleted directory: {filepath}"
    
    async def move_file(self, source: str, destination: str) -> str:
        """Move or rename file"""
        src_path = self._resolve_path(source)
        dst_path = self._resolve_path(destination)
        
        if not src_path.exists():
            raise FileNotFoundError(f"Source not found: {source}")
        
        # Create destination parent dirs
        dst_path.parent.mkdir(parents=True, exist_ok=True)
        
        src_path.rename(dst_path)
        logger.info(f"ğŸ“¦ Moved: {source} â†’ {destination}")
        return f"Moved {source} to {destination}"
    
    async def copy_file(self, source: str, destination: str) -> str:
        """Copy file"""
        src_path = self._resolve_path(source)
        dst_path = self._resolve_path(destination)
        
        if not src_path.exists():
            raise FileNotFoundError(f"Source not found: {source}")
        
        # Create destination parent dirs
        dst_path.parent.mkdir(parents=True, exist_ok=True)
        
        import shutil
        if src_path.is_file():
            shutil.copy2(src_path, dst_path)
        else:
            shutil.copytree(src_path, dst_path)
        
        logger.info(f"ğŸ“„ Copied: {source} â†’ {destination}")
        return f"Copied {source} to {destination}"
    
    async def search_files(self, pattern: str, directory: str = ".", extensions: Optional[List[str]] = None) -> List[Dict]:
        """Search files by content"""
        search_path = self._resolve_path(directory)
        matches = []
        
        for file_path in search_path.rglob("*"):
            if not file_path.is_file():
                continue
            
            if extensions and file_path.suffix not in extensions:
                continue
            
            try:
                async with aiofiles.open(file_path, 'r', encoding='utf-8') as f:
                    content = await f.read()
                    if pattern in content:
                        # Find line numbers
                        lines = content.split('\n')
                        line_numbers = [i + 1 for i, line in enumerate(lines) if pattern in line]
                        
                        relative_path = file_path.relative_to(self.base_path)
                        matches.append({
                            "file": str(relative_path),
                            "lines": line_numbers[:10]  # Limit to first 10 matches
                        })
            except Exception as e:
                logger.debug(f"Could not search {file_path}: {e}")
        
        logger.info(f"ğŸ” Search found {len(matches)} files matching '{pattern}'")
        return matches


# ============================================================================
# CODE EXECUTION & DATA ANALYSIS HELPERS
# ============================================================================

async def execute_python_code(code: str, return_stdout: bool = True, return_plots: bool = True) -> str:
    """
    Execute Python code in a safe sandbox with pandas, numpy, matplotlib available.
    Returns stdout output and/or base64-encoded plots.
    """
    import io
    import sys
    import base64
    from contextlib import redirect_stdout
    
    try:
        # Import analysis libraries
        import pandas as pd
        import numpy as np
        import matplotlib
        matplotlib.use('Agg')  # Non-interactive backend
        import matplotlib.pyplot as plt
        import seaborn as sns
        
        # Capture stdout
        stdout_capture = io.StringIO()
        plots = []
        
        # Create safe globals with common libraries
        safe_globals = {
            'pd': pd,
            'np': np,
            'plt': plt,
            'sns': sns,
            '__builtins__': __builtins__,
        }
        
        # Execute code
        with redirect_stdout(stdout_capture):
            exec(code, safe_globals)
        
        # Capture any matplotlib figures
        if return_plots and plt.get_fignums():
            for fig_num in plt.get_fignums():
                fig = plt.figure(fig_num)
                buf = io.BytesIO()
                fig.savefig(buf, format='png', bbox_inches='tight', dpi=100)
                buf.seek(0)
                img_base64 = base64.b64encode(buf.read()).decode('utf-8')
                plots.append(f"data:image/png;base64,{img_base64}")
                plt.close(fig)
        
        # Build response
        result = {}
        
        if return_stdout:
            stdout_text = stdout_capture.getvalue()
            if stdout_text:
                result['stdout'] = stdout_text
        
        if return_plots and plots:
            result['plots'] = plots
        
        if not result:
            result['message'] = "Code executed successfully (no output)"
        
        return json.dumps(result, indent=2)
    
    except Exception as e:
        logger.error(f"Python execution error: {e}")
        return json.dumps({
            'error': str(e),
            'type': type(e).__name__
        }, indent=2)


async def analyze_states_as_dataframe(
    ha_api: HomeAssistantAPI,
    domain: Optional[str] = None,
    include_attributes: bool = True,
    query: Optional[str] = None
) -> str:
    """
    Get HA states as a pandas DataFrame for analysis.
    Returns JSON representation of the DataFrame.
    """
    try:
        import pandas as pd
        
        # Get states
        states = await ha_api.get_states()
        
        # Filter by domain if specified
        if domain:
            states = [s for s in states if s['entity_id'].startswith(f"{domain}.")]
        
        # Build DataFrame
        data = []
        for state in states:
            row = {
                'entity_id': state['entity_id'],
                'state': state['state'],
                'last_changed': state.get('last_changed'),
                'last_updated': state.get('last_updated')
            }
            
            # Add attributes if requested
            if include_attributes and 'attributes' in state:
                for key, value in state['attributes'].items():
                    # Flatten attributes (convert complex types to strings)
                    if isinstance(value, (list, dict)):
                        row[f'attr_{key}'] = json.dumps(value)
                    else:
                        row[f'attr_{key}'] = value
            
            data.append(row)
        
        df = pd.DataFrame(data)
        
        # Apply query filter if specified
        if query:
            df = df.query(query)
        
        # Return as JSON with metadata
        result = {
            'shape': df.shape,
            'columns': list(df.columns),
            'dtypes': {col: str(dtype) for col, dtype in df.dtypes.items()},
            'data': df.to_dict(orient='records'),
            'summary': {
                'total_entities': len(df),
                'domains': df['entity_id'].str.split('.').str[0].value_counts().to_dict() if len(df) > 0 else {}
            }
        }
        
        return json.dumps(result, indent=2, default=str)
    
    except Exception as e:
        logger.error(f"DataFrame analysis error: {e}")
        return json.dumps({
            'error': str(e),
            'type': type(e).__name__
        }, indent=2)


async def plot_sensor_history_chart(
    ha_api: HomeAssistantAPI,
    entity_ids: List[str],
    hours: int = 24,
    chart_type: str = "line",
    title: Optional[str] = None
) -> str:
    """
    Plot sensor history as a time-series chart.
    Returns base64-encoded PNG image.
    """
    try:
        import pandas as pd
        import matplotlib
        matplotlib.use('Agg')
        import matplotlib.pyplot as plt
        from datetime import datetime, timedelta
        import base64
        import io
        
        # Get history for each entity
        end_time = datetime.now()
        start_time = end_time - timedelta(hours=hours)
        
        # Note: We'll use get_states for now since we don't have get_entity_history in current tools
        # In a real implementation, you'd call the HA history API
        all_data = []
        
        for entity_id in entity_ids:
            try:
                state = await ha_api.get_state(entity_id)
                # For now, just plot current state (you'd extend this to get full history)
                all_data.append({
                    'entity_id': entity_id,
                    'timestamp': datetime.now(),
                    'value': float(state['state']) if state['state'] not in ['unavailable', 'unknown'] else None
                })
            except Exception as e:
                logger.warning(f"Could not get state for {entity_id}: {e}")
        
        if not all_data:
            return json.dumps({'error': 'No data available for plotting'})
        
        df = pd.DataFrame(all_data)
        
        # Create plot
        fig, ax = plt.subplots(figsize=(12, 6))
        
        if chart_type == "line":
            for entity_id in entity_ids:
                entity_data = df[df['entity_id'] == entity_id]
                if not entity_data.empty:
                    ax.plot(entity_data['timestamp'], entity_data['value'], marker='o', label=entity_id)
        
        elif chart_type == "bar":
            df.pivot(index='timestamp', columns='entity_id', values='value').plot(kind='bar', ax=ax)
        
        elif chart_type == "scatter":
            for entity_id in entity_ids:
                entity_data = df[df['entity_id'] == entity_id]
                if not entity_data.empty:
                    ax.scatter(entity_data['timestamp'], entity_data['value'], label=entity_id, s=100)
        
        # Formatting
        ax.set_title(title or f'Sensor History - Last {hours} Hours')
        ax.set_xlabel('Time')
        ax.set_ylabel('Value')
        ax.legend()
        ax.grid(True, alpha=0.3)
        plt.xticks(rotation=45)
        plt.tight_layout()
        
        # Convert to base64
        buf = io.BytesIO()
        fig.savefig(buf, format='png', bbox_inches='tight', dpi=100)
        buf.seek(0)
        img_base64 = base64.b64encode(buf.read()).decode('utf-8')
        plt.close(fig)
        
        return json.dumps({
            'plot': f"data:image/png;base64,{img_base64}",
            'entities_plotted': entity_ids,
            'data_points': len(df),
            'time_range_hours': hours
        }, indent=2)
    
    except Exception as e:
        logger.error(f"Plotting error: {e}")
        return json.dumps({
            'error': str(e),
            'type': type(e).__name__
        }, indent=2)


# Initialize managers
ha_api = HomeAssistantAPI()
file_mgr = FileManager(HA_CONFIG_PATH)




# ============================================================================
# TOOL DEFINITIONS FROM CONVERTED PARTS
# ============================================================================

def get_part1_tools() -> list[Tool]:
    """
    Returns Part 1 tool definitions to merge into server.py list_tools()
    Copy these into the main list_tools() function
    """
    return [
        # =================================================================
        # DEVICE DISCOVERY & STATE MANAGEMENT
        # =================================================================
        
        Tool(
            name="discover_devices",
            description=(
                "ğŸ” **Intelligent Device Discovery with Smart Filtering**\n\n"
                "Discovers ALL Home Assistant entities with advanced filtering and categorization.\n\n"
                "**FEATURES:**\n"
                "- Filter by domain (light, switch, sensor, climate, media_player, etc.)\n"
                "- Filter by area/room (kitchen, bedroom, living_room)\n"
                "- Filter by state (on, off, unavailable, unknown)\n"
                "- Filter by attribute patterns (brightness > 50, battery < 20%)\n"
                "- Returns: entity_id, friendly_name, state, domain, area, last_changed\n\n"
                "**SMART USE CASES:**\n"
                "- 'Find all lights in the kitchen' â†’ domain='light', area='kitchen'\n"
                "- 'Show me battery sensors below 20%' â†’ domain='sensor', attribute_filter={'battery': '<20'}\n"
                "- 'List unavailable devices' â†’ state_filter='unavailable'\n"
                "- 'All media players currently playing' â†’ domain='media_player', state_filter='playing'\n\n"
                "**RETURNS:** Structured list with entity details, organized by domain/area.\n\n"
                "**RELATED TOOLS:** Use get_device_state() for detailed single entity info, "
                "or get_area_devices() when you already know the area name."
            ),
            inputSchema={
                "type": "object",
                "properties": {
                    "domain": {
                        "type": "string",
                        "description": "Filter by domain (light, switch, sensor, climate, media_player, cover, fan, etc.)",
                        "enum": ["light", "switch", "sensor", "binary_sensor", "climate", "media_player", 
                                "cover", "fan", "lock", "camera", "alarm_control_panel", "vacuum", "all"]
                    },
                    "area": {
                        "type": "string",
                        "description": "Filter by area/room name (e.g., 'kitchen', 'bedroom', 'living_room')"
                    },
                    "state_filter": {
                        "type": "string",
                        "description": "Filter by current state (on, off, playing, paused, unavailable, unknown)"
                    },
                    "limit": {
                        "type": "integer",
                        "description": "Maximum results to return (default: 100)",
                        "default": 100
                    }
                }
            }
        ),
        
        Tool(
            name="get_device_state",
            description=(
                "ğŸ“Š **Comprehensive Device State Inspector**\n\n"
                "Get COMPLETE state information for any Home Assistant entity with full context.\n\n"
                "**RETURNS:**\n"
                "- Current state (on/off/value)\n"
                "- All attributes (brightness, color, temperature, battery, etc.)\n"
                "- Metadata (friendly_name, device_class, unit_of_measurement)\n"
                "- Timing (last_changed, last_updated)\n"
                "- Context (area, device info, related entities)\n\n"
                "**SMART ANALYSIS:**\n"
                "- Light: brightness (0-255), RGB color, color_temp, effect mode\n"
                "- Climate: current_temp, target_temp, hvac_mode, fan_mode\n"
                "- Sensor: value, unit, battery level, device_class\n"
                "- Media Player: source, volume, media_title, app_name\n"
                "- Switch/Lock: state, battery (if applicable)\n\n"
                "**USE CASES:**\n"
                "- 'What's the current state of kitchen light?' â†’ Brightness, color, on/off\n"
                "- 'Check living room thermostat' â†’ Current temp, target, mode\n"
                "- 'Is front door locked?' â†’ State + battery level\n"
                "- 'What's playing on TV?' â†’ Media info, volume, source\n\n"
                "**RELATED TOOLS:** Use discover_devices() when entity_id is unknown, get_area_devices() for all devices in a room."
            ),
            inputSchema={
                "type": "object",
                "properties": {
                    "entity_id": {
                        "type": "string",
                        "description": "Entity ID to inspect (e.g., 'light.kitchen', 'climate.thermostat', 'media_player.tv')"
                    }
                },
                "required": ["entity_id"]
            }
        ),
        
        Tool(
            name="get_area_devices",
            description=(
                "ğŸ  **Area/Room Device Lister with Grouping**\n\n"
                "Get ALL devices in a specific area/room, organized by type (lights, switches, sensors, etc.).\n\n"
                "**FEATURES:**\n"
                "- Groups devices by domain automatically\n"
                "- Shows current state for each device\n"
                "- Includes device metadata (friendly names, capabilities)\n"
                "- Identifies controllable vs. read-only devices\n\n"
                "**RETURNS (organized by type):**\n"
                "- Lights: with current brightness/color state\n"
                "- Switches: on/off state\n"
                "- Sensors: current readings\n"
                "- Climate: temperature, mode\n"
                "- Media Players: playing/paused state\n"
                "- Covers/Blinds: open/closed position\n\n"
                "**USE CASES:**\n"
                "- 'What devices are in the kitchen?' â†’ All kitchen entities grouped\n"
                "- 'Show bedroom lights and switches' â†’ Controllable bedroom devices\n"
                "- 'List all living room sensors' â†’ Temperature, motion, etc.\n\n"
                "**WORKFLOW:** After getting area devices, use control_light(), control_switch(), etc. "
                "after identifying target entity_ids."
            ),
            inputSchema={
                "type": "object",
                "properties": {
                    "area": {
                        "type": "string",
                        "description": "Area/room name (kitchen, bedroom, living_room, office, etc.)"
                    },
                    "include_unavailable": {
                        "type": "boolean",
                        "description": "Include offline/unavailable devices (default: false)",
                        "default": False
                    },
                    "device_types": {
                        "type": "array",
                        "items": {"type": "string"},
                        "description": "Filter by device types (light, switch, sensor, climate, media_player)"
                    }
                },
                "required": ["area"]
            }
        ),
        
        # =================================================================
        # BASIC DEVICE CONTROL
        # =================================================================
        
        Tool(
            name="control_light",
            description=(
                "ğŸ’¡ **Advanced Light Control with Color & Effects**\n\n"
                "Control lights with full capability support: on/off, brightness, color, temperature, effects.\n\n"
                "**ACTIONS:**\n"
                "- turn_on: Power on with optional brightness/color\n"
                "- turn_off: Power off\n"
                "- toggle: Switch state\n"
                "- set_brightness: Adjust brightness (0-255 or 0-100%)\n"
                "- set_color: RGB color or color name\n"
                "- set_temperature: Color temperature (warm to cool)\n"
                "- set_effect: Special effects (flash, colorloop, etc.)\n\n"
                "**PARAMETERS:**\n"
                "- brightness: 0-255 or percentage string '50%'\n"
                "- rgb_color: [R, G, B] e.g., [255, 0, 0] for red\n"
                "- color_temp: Kelvin (2000-6500) or mireds\n"
                "- transition: Fade time in seconds\n\n"
                "**RELATED TOOLS:** Use adaptive_lighting() for context-aware control, scene_based_lighting() for activity presets."
            ),
            inputSchema={
                "type": "object",
                "properties": {
                    "entity_id": {"type": "string", "description": "Light entity ID or comma-separated list"},
                    "action": {
                        "type": "string",
                        "enum": ["turn_on", "turn_off", "toggle"],
                        "description": "Light action"
                    },
                    "brightness": {
                        "type": "integer",
                        "description": "Brightness (0-255)",
                        "minimum": 0,
                        "maximum": 255
                    },
                    "brightness_pct": {
                        "type": "integer",
                        "description": "Brightness percentage (0-100)",
                        "minimum": 0,
                        "maximum": 100
                    },
                    "rgb_color": {
                        "type": "array",
                        "items": {"type": "integer"},
                        "description": "RGB color [r, g, b] (0-255 each)"
                    },
                    "color_temp": {
                        "type": "integer",
                        "description": "Color temperature in Kelvin (2000-6500) or mireds"
                    },
                    "effect": {
                        "type": "string",
                        "description": "Light effect (colorloop, flash, etc.)"
                    },
                    "transition": {
                        "type": "integer",
                        "description": "Transition time in seconds"
                    }
                },
                "required": ["entity_id", "action"]
            }
        ),
        
        Tool(
            name="control_switch",
            description=(
                "ğŸ”Œ **Smart Switch Control**\n\n"
                "Control switches, outlets, and other binary devices.\n\n"
                "**ACTIONS:**\n"
                "- turn_on: Power on the switch\n"
                "- turn_off: Power off the switch\n"
                "- toggle: Switch between on/off states\n\n"
                "**USE CASES:**\n"
                "- Control power outlets\n"
                "- Toggle smart plugs\n"
                "- Control relay switches\n"
                "- Manage energy monitoring switches\n\n"
                "**RELATED TOOLS:** control_light() for lights, control_climate() for HVAC, control_cover() for blinds."
            ),
            inputSchema={
                "type": "object",
                "properties": {
                    "entity_id": {"type": "string", "description": "Switch entity ID"},
                    "action": {
                        "type": "string",
                        "enum": ["turn_on", "turn_off", "toggle"],
                        "description": "Switch action"
                    }
                },
                "required": ["entity_id", "action"]
            }
        ),
        
        Tool(
            name="control_climate",
            description=(
                "ğŸŒ¡ï¸ **Advanced Climate Control (HVAC/Thermostat)**\n\n"
                "Control thermostats, air conditioners, heaters with full HVAC mode support.\n\n"
                "**ACTIONS:**\n"
                "- set_temperature: Change target temperature\n"
                "- set_hvac_mode: Change mode (heat, cool, auto, off, heat_cool)\n"
                "- set_fan_mode: Change fan mode (auto, on, low, high, etc.)\n"
                "- set_preset_mode: Use preset (away, home, sleep, eco)\n"
                "- set_humidity: Target humidity level\n\n"
                "**HVAC MODES:**\n"
                "- heat: Heating only\n"
                "- cool: Cooling only\n"
                "- heat_cool: Auto heating/cooling\n"
                "- auto: Automatic mode\n"
                "- off: HVAC off\n"
                "- dry: Dehumidify mode\n"
                "- fan_only: Fan without heating/cooling\n\n"
                "**SMART FEATURES:**\n"
                "- Dual setpoint support (heat + cool targets)\n"
                "- Preset modes for energy efficiency\n"
                "- Fan speed control\n"
                "- Humidity control (if supported)\n\n"
                "**RELATED TOOLS:** Use smart_thermostat() for schedule-based control, zone_temperature_control() for multi-room systems."
            ),
            inputSchema={
                "type": "object",
                "properties": {
                    "entity_id": {"type": "string", "description": "Climate entity ID"},
                    "temperature": {"type": "number", "description": "Target temperature"},
                    "target_temp_high": {"type": "number", "description": "Upper temperature (heat_cool mode)"},
                    "target_temp_low": {"type": "number", "description": "Lower temperature (heat_cool mode)"},
                    "hvac_mode": {
                        "type": "string",
                        "enum": ["heat", "cool", "heat_cool", "auto", "off", "dry", "fan_only"],
                        "description": "HVAC operation mode"
                    },
                    "fan_mode": {"type": "string", "description": "Fan mode (auto, on, low, medium, high)"},
                    "preset_mode": {"type": "string", "description": "Preset mode (away, home, sleep, eco)"},
                    "humidity": {"type": "integer", "description": "Target humidity percentage"}
                },
                "required": ["entity_id"]
            }
        ),
        
        Tool(
            name="control_cover",
            description=(
                "ğŸªŸ **Smart Cover/Blind Control**\n\n"
                "Control blinds, shades, curtains, garage doors, and other cover entities.\n\n"
                "**ACTIONS:**\n"
                "- open_cover: Fully open\n"
                "- close_cover: Fully close\n"
                "- stop_cover: Stop movement\n"
                "- toggle: Switch between open/closed\n"
                "- set_position: Set to specific position (0-100%)\n"
                "- set_tilt_position: Adjust slat angle (venetian blinds)\n\n"
                "**POSITION CONTROL:**\n"
                "- 0% = Fully closed\n"
                "- 50% = Half open\n"
                "- 100% = Fully open\n\n"
                "**USE CASES:**\n"
                "- 'Open living room blinds 75%' â†’ set_position: 75\n"
                "- 'Close bedroom curtains' â†’ close_cover\n"
                "- 'Open garage door' â†’ open_cover\n"
                "- 'Tilt blinds 45 degrees' â†’ set_tilt_position\n\n"
                "**SMART AUTOMATION:** Use circadian_rhythm_blinds() for sun-based automation, "
                "weather_based_automation() to adjust based on sun/temperature."
            ),
            inputSchema={
                "type": "object",
                "properties": {
                    "entity_id": {"type": "string", "description": "Cover entity ID"},
                    "action": {
                        "type": "string",
                        "enum": ["open_cover", "close_cover", "stop_cover", "toggle"],
                        "description": "Cover action"
                    },
                    "position": {
                        "type": "integer",
                        "description": "Position percentage (0-100)",
                        "minimum": 0,
                        "maximum": 100
                    },
                    "tilt_position": {
                        "type": "integer",
                        "description": "Tilt position for venetian blinds (0-100)",
                        "minimum": 0,
                        "maximum": 100
                    }
                },
                "required": ["entity_id", "action"]
            }
        ),
        
        # =================================================================
        # ADVANCED LIGHTING CONTROL
        # =================================================================
        
        Tool(
            name="adaptive_lighting",
            description=(
                "ğŸŒ… **Context-Aware Adaptive Lighting**\n\n"
                "Automatically adjusts lighting based on time of day, sun position, ambient light, and activity.\n\n"
                "**ADAPTS TO:**\n"
                "- Time of day (morning bright, evening warm)\n"
                "- Sun position (sunrise/sunset transitions)\n"
                "- Ambient light sensors (darken if room is bright)\n"
                "- Occupancy/motion (different levels for activity vs. presence)\n"
                "- Activity type (reading, watching TV, cooking, relaxing)\n\n"
                "**AUTOMATIC ADJUSTMENTS:**\n"
                "- Morning (6-9 AM): Cool white, energizing brightness\n"
                "- Day (9 AM-5 PM): Bright, neutral white\n"
                "- Evening (5-9 PM): Warm white, moderate brightness\n"
                "- Night (9 PM+): Dim warm light, sleep-friendly\n\n"
                "**ACTIVITY PRESETS:**\n"
                "- reading: Bright cool white focused light\n"
                "- watching_tv: Dim warm ambient lighting\n"
                "- cooking: Bright task lighting\n"
                "- relaxing: Soft warm glow\n"
                "- working: Bright neutral white\n\n"
                "**RELATED TOOLS:** Use circadian_lighting() for health-focused rhythms, "
                "control_light() for manual override, multi_room_lighting_sync() to coordinate multiple rooms with same activity."
            ),
            inputSchema={
                "type": "object",
                "properties": {
                    "entity_id": {"type": "string", "description": "Light or group to control"},
                    "activity": {
                        "type": "string",
                        "enum": ["reading", "watching_tv", "cooking", "relaxing", "working", "auto"],
                        "description": "Current activity (auto = time-based)"
                    },
                    "use_ambient_sensor": {
                        "type": "boolean",
                        "description": "Use ambient light sensor for brightness adjustment"
                    },
                    "ambient_sensor": {
                        "type": "string",
                        "description": "Entity ID of ambient light sensor"
                    },
                    "motion_sensor": {
                        "type": "string",
                        "description": "Motion sensor for occupancy detection"
                    }
                },
                "required": ["entity_id"]
            }
        ),
        
        Tool(
            name="circadian_lighting",
            description=(
                "â˜€ï¸ **Health-Optimized Circadian Rhythm Lighting**\n\n"
                "Aligns lighting with natural circadian rhythms for better sleep and alertness.\n\n"
                "**SCIENCE-BASED LIGHTING:**\n"
                "- Morning: High color temp (5500-6500K), bright â†’ Cortisol boost, alertness\n"
                "- Midday: Neutral white (4000-5000K) â†’ Sustained focus\n"
                "- Afternoon: Gradual warm shift (3500-4000K) â†’ Natural wind-down\n"
                "- Evening: Warm white (2700-3000K), dimmed â†’ Melatonin production\n"
                "- Night: Very warm (2000-2500K), very dim â†’ Sleep preparation\n\n"
                "**HEALTH BENEFITS:**\n"
                "- Improved sleep quality\n"
                "- Better morning alertness\n"
                "- Reduced eye strain\n"
                "- Natural hormone regulation\n\n"
                "**CUSTOMIZATION:**\n"
                "- sleep_time: When to shift to sleep-friendly lighting\n"
                "- wake_time: When to start energizing morning light\n"
                "- transition_duration: How gradually to change (minutes)\n\n"
                "**MODES:**\n"
                "- normal: Standard circadian curve\n"
                "- sleep: Extra warm/dim for sleep issues\n"
                "- energize: Brighter/cooler for alertness\n\n"
                "**RELATED TOOLS:** Use adaptive_lighting() for activity-based control, "
                "control_light() for manual override, bedtime_routine() to transition to sleep mode."
            ),
            inputSchema={
                "type": "object",
                "properties": {
                    "entity_id": {"type": "string", "description": "Light or group to control"},
                    "mode": {
                        "type": "string",
                        "enum": ["normal", "sleep", "energize"],
                        "description": "Circadian mode"
                    },
                    "sleep_time": {
                        "type": "string",
                        "description": "Bedtime (HH:MM format, e.g., '22:00')"
                    },
                    "wake_time": {
                        "type": "string",
                        "description": "Wake time (HH:MM format, e.g., '07:00')"
                    },
                    "transition_duration": {
                        "type": "integer",
                        "description": "Transition duration in minutes (default: 30)",
                        "default": 30
                    },
                    "min_brightness": {
                        "type": "integer",
                        "description": "Minimum brightness (0-255, default: 10)",
                        "default": 10
                    },
                    "max_brightness": {
                        "type": "integer",
                        "description": "Maximum brightness (0-255, default: 255)",
                        "default": 255
                    }
                },
                "required": ["entity_id"]
            }
        ),
        
        Tool(
            name="multi_room_lighting_sync",
            description=(
                "ğŸ¡ **Multi-Room Lighting Synchronization**\n\n"
                "Synchronize lighting across multiple rooms for consistent whole-home atmosphere.\n\n"
                "**FEATURES:**\n"
                "- Apply same scene/settings to multiple rooms\n"
                "- Gradual room-by-room transitions\n"
                "- Zone-based control (upstairs, downstairs, etc.)\n"
                "- Activity-based synchronization\n\n"
                "**SYNC MODES:**\n"
                "- instant: All rooms change simultaneously\n"
                "- wave: Gradual room-by-room transition\n"
                "- follow: Lights follow user movement between rooms\n\n"
                "**USE CASES:**\n"
                "- 'Set all downstairs lights to movie mode'\n"
                "- 'Sync bedroom and hallway for nighttime navigation'\n"
                "- 'Create party lighting across living spaces'\n"
                "- 'Gradual wake-up lighting cascade from bedroom to kitchen'\n\n"
                "**ACTIVITY PRESETS:**\n"
                "- movie: Dim ambient lighting\n"
                "- party: Dynamic colorful lighting\n"
                "- dinner: Warm intimate lighting\n"
                "- cleanup: Bright task lighting\n"
                "- bedtime: Progressive dimming sequence\n\n"
                "**RELATED TOOLS:** Use adaptive_lighting() for individual room intelligence, "
                "whole_home_scene() for complex multi-device coordination beyond just lights."
            ),
            inputSchema={
                "type": "object",
                "properties": {
                    "rooms": {
                        "type": "array",
                        "items": {"type": "string"},
                        "description": "List of room/area names to sync"
                    },
                    "activity": {
                        "type": "string",
                        "enum": ["movie", "party", "dinner", "cleanup", "bedtime", "custom"],
                        "description": "Activity preset to apply"
                    },
                    "sync_mode": {
                        "type": "string",
                        "enum": ["instant", "wave", "follow"],
                        "description": "How to synchronize (default: instant)",
                        "default": "instant"
                    },
                    "custom_brightness": {
                        "type": "integer",
                        "description": "Custom brightness for all rooms (0-255)"
                    },
                    "custom_color_temp": {
                        "type": "integer",
                        "description": "Custom color temp for all rooms (Kelvin)"
                    },
                    "transition_delay": {
                        "type": "integer",
                        "description": "Delay between rooms in wave mode (seconds)"
                    }
                },
                "required": ["rooms", "activity"]
            }
        ),
        
        Tool(
            name="presence_based_lighting",
            description=(
                "ğŸ‘¤ **Presence-Aware Smart Lighting**\n\n"
                "Automatically turn lights on/off based on room occupancy with intelligent timeout.\n\n"
                "**FEATURES:**\n"
                "- Motion sensor integration\n"
                "- Configurable timeout before turning off\n"
                "- Manual override detection (if user turned off manually, respect it)\n"
                "- Time-of-day brightness adjustment\n"
                "- Activity-based scene selection\n\n"
                "**USE CASES:**\n"
                "- Hallway: Turn on when motion, off 2 minutes after last motion\n"
                "- Bathroom: Bright when occupied, off when empty\n"
                "- Closet: On when door opens, off when closed\n"
                "- Garage: On when entered, off 10 minutes after exit\n\n"
                "**RELATED TOOLS:** adaptive_lighting() for context-aware brightness/color"
            ),
            inputSchema={
                "type": "object",
                "properties": {
                    "light_entity": {"type": "string", "description": "Light to control"},
                    "motion_sensor": {"type": "string", "description": "Motion sensor entity"},
                    "timeout_seconds": {
                        "type": "integer",
                        "description": "Seconds to wait before turning off (default: 300)",
                        "default": 300
                    },
                    "respect_manual_off": {
                        "type": "boolean",
                        "description": "Don't auto-turn-on if manually turned off (default: true)",
                        "default": True
                    }
                },
                "required": ["light_entity", "motion_sensor"]
            }
        ),
        
        # =================================================================
        # MEDIA PLAYER CONTROL
        # =================================================================
        
        Tool(
            name="control_media_player",
            description=(
                "ğŸµ **Advanced Media Player Control**\n\n"
                "Control TVs, speakers, receivers, and streaming devices with comprehensive actions.\n\n"
                "**PLAYBACK ACTIONS:**\n"
                "- turn_on, turn_off: Power control\n"
                "- play, pause, stop: Playback control\n"
                "- media_next_track, media_previous_track: Track navigation\n"
                "- media_play_pause: Toggle play/pause\n\n"
                "**VOLUME CONTROL:**\n"
                "- volume_set: Set volume (0.0-1.0)\n"
                "- volume_up, volume_down: Adjust volume\n"
                "- mute, unmute: Mute control\n\n"
                "**SOURCE/INPUT:**\n"
                "- select_source: Choose input (HDMI1, Chromecast, Bluetooth, etc.)\n\n"
                "**ACTIONS:** turn_on, turn_off, play, pause, stop, mute, unmute, volume_set, volume_up, volume_down, select_source, media_next_track, media_previous_track"
            ),
            inputSchema={
                "type": "object",
                "properties": {
                    "entity_id": {"type": "string", "description": "Media player entity ID"},
                    "action": {
                        "type": "string",
                        "enum": ["turn_on", "turn_off", "play", "pause", "stop", "toggle", 
                                "volume_up", "volume_down", "mute", "unmute", "media_next_track", "media_previous_track"],
                        "description": "Media player action"
                    },
                    "volume_level": {
                        "type": "number",
                        "description": "Volume level (0.0-1.0)",
                        "minimum": 0.0,
                        "maximum": 1.0
                    },
                    "source": {"type": "string", "description": "Input source name"}
                },
                "required": ["entity_id", "action"]
            }
        ),
        
        Tool(
            name="play_media",
            description=(
                "â–¶ï¸ **Play Media Content**\n\n"
                "Play specific media content (music, video, radio, playlists) on media players.\n\n"
                "Supports URLs, Spotify URIs, local files, and streaming services."
            ),
            inputSchema={
                "type": "object",
                "properties": {
                    "entity_id": {"type": "string", "description": "Media player entity ID"},
                    "media_content_id": {"type": "string", "description": "URL or media identifier"},
                    "media_content_type": {
                        "type": "string",
                        "description": "Media type (music, video, playlist, etc.)"
                    }
                },
                "required": ["entity_id", "media_content_id", "media_content_type"]
            }
        ),
        
        Tool(
            name="multi_room_audio_sync",
            description=(
                "ğŸ”Š **Multi-Room Audio Synchronization**\n\n"
                "Play synchronized audio across multiple speakers/rooms. Perfect for whole-home audio or party mode.\n\n"
                "**FEATURES:**\n"
                "- Synchronized playback across rooms\n"
                "- Volume balancing\n"
                "- Group management\n\n"
                "**USE CASES:**\n"
                "- Play music in kitchen + living room simultaneously\n"
                "- Whole-home announcements\n"
                "- Party mode audio distribution"
            ),
            inputSchema={
                "type": "object",
                "properties": {
                    "media_players": {
                        "type": "array",
                        "items": {"type": "string"},
                        "description": "List of media player entity IDs to sync"
                    },
                    "master_player": {"type": "string", "description": "Primary player (controls others)"},
                    "media_content_id": {"type": "string", "description": "Media to play"},
                    "volume_level": {"type": "number", "description": "Volume for all (0.0-1.0)"}
                },
                "required": ["media_players"]
            }
        ),
        
        Tool(
            name="party_mode",
            description=(
                "ğŸ‰ **Party Mode Activation**\n\n"
                "Transform your home into party mode: dynamic colorful lighting, multi-room audio, and optimized climate.\n\n"
                "**ACTIVATES:**\n"
                "- Colorful dynamic lighting (color loops, effects)\n"
                "- Multi-room synchronized audio\n"
                "- Climate adjustments (cooler for more people)\n"
                "- All entertainment devices coordinated\n\n"
                "**CUSTOMIZATION:**\n"
                "- Light intensity and color patterns\n"
                "- Audio zones and volume levels\n"
                "- Climate presets for crowd comfort"
            ),
            inputSchema={
                "type": "object",
                "properties": {
                    "rooms": {
                        "type": "array",
                        "items": {"type": "string"},
                        "description": "Rooms to include in party mode"
                    },
                    "music_source": {"type": "string", "description": "Media content to play"},
                    "light_intensity": {
                        "type": "string",
                        "enum": ["low", "medium", "high"],
                        "description": "Light effect intensity"
                    },
                    "volume_level": {"type": "number", "description": "Music volume (0.0-1.0)"}
                },
                "required": ["rooms"]
            }
        ),
        
        # =================================================================
        # CLIMATE & ENVIRONMENT
        # =================================================================
        
        Tool(
            name="smart_thermostat_optimization",
            description=(
                "ğŸŒ¡ï¸ **Smart Thermostat with Occupancy & Schedule**\n\n"
                "Optimize thermostat based on occupancy, schedule, and weather for maximum efficiency and comfort.\n\n"
                "**FEATURES:**\n"
                "- Occupancy-based setbacks (lower temp when away)\n"
                "- Schedule integration (work hours, sleep hours)\n"
                "- Weather-based pre-cooling/pre-heating\n"
                "- Energy efficiency optimization\n\n"
                "**MODES:**\n"
                "- home: Comfort mode (normal temps)\n"
                "- away: Energy saving (setback temps)\n"
                "- sleep: Nighttime temps\n"
                "- eco: Maximum energy efficiency"
            ),
            inputSchema={
                "type": "object",
                "properties": {
                    "entity_id": {"type": "string", "description": "Climate entity ID"},
                    "mode": {
                        "type": "string",
                        "enum": ["home", "away", "sleep", "eco"],
                        "description": "Thermostat mode"
                    },
                    "occupancy_sensor": {"type": "string", "description": "Occupancy/motion sensor entity"},
                    "schedule": {
                        "type": "object",
                        "description": "Temperature schedule by time of day"
                    }
                },
                "required": ["entity_id", "mode"]
            }
        ),
        
        Tool(
            name="zone_climate_control",
            description=(
                "ğŸ  **Multi-Zone Climate Control**\n\n"
                "Control different temperature zones independently for personalized comfort.\n\n"
                "Perfect for multi-zone HVAC or room-by-room temperature management."
            ),
            inputSchema={
                "type": "object",
                "properties": {
                    "zones": {
                        "type": "array",
                        "items": {
                            "type": "object",
                            "properties": {
                                "name": {"type": "string"},
                                "entity_id": {"type": "string"},
                                "target_temp": {"type": "number"}
                            }
                        },
                        "description": "List of zones with target temperatures"
                    }
                },
                "required": ["zones"]
            }
        ),
        
        Tool(
            name="air_quality_management",
            description=(
                "ğŸŒ¬ï¸ **Air Quality Management & Ventilation**\n\n"
                "Monitor and control air quality with fans, purifiers, and automated ventilation.\n\n"
                "Controls fans, purifiers, and windows based on indoor/outdoor air quality."
            ),
            inputSchema={
                "type": "object",
                "properties": {
                    "air_quality_sensor": {"type": "string", "description": "Air quality sensor entity"},
                    "fan_entity": {"type": "string", "description": "Fan or purifier to control"},
                    "target_aqi": {
                        "type": "integer",
                        "description": "Target AQI threshold (turn on if exceeded)"
                    },
                    "window_entities": {
                        "type": "array",
                        "items": {"type": "string"},
                        "description": "Smart windows to open for ventilation"
                    }
                },
                "required": ["air_quality_sensor"]
            }
        ),
    ]


# ============================================================================
# PART 1: TOOL HANDLERS (to add to call_tool() in server.py)
# ============================================================================



def get_part2_tools() -> list[Tool]:
    """
    Returns Part 2 tool definitions to merge into server.py list_tools()
    Copy these into the main list_tools() function
    """
    return [
        # =================================================================
        # SECURITY & MONITORING
        # =================================================================
        
        Tool(
            name="intelligent_security_monitor",
            description=(
                "ğŸ”’ **Intelligent Security Monitoring with AI Analysis**\n\n"
                "Analyzes door/window sensors, cameras, motion patterns. Alerts on unusual activity."
            ),
            inputSchema={
                "type": "object",
                "properties": {
                    "sensor_entities": {
                        "type": "array",
                        "items": {"type": "string"},
                        "description": "List of door/window/motion sensor entities to monitor"
                    },
                    "alert_entity": {
                        "type": "string",
                        "description": "Entity to notify on anomalies (notify service, etc.)"
                    },
                    "baseline_hours": {
                        "type": "integer",
                        "description": "Hours of history to establish baseline (default: 24)",
                        "default": 24
                    }
                },
                "required": ["sensor_entities"]
            }
        ),
        
        Tool(
            name="anomaly_detection",
            description=(
                "ğŸš¨ **Anomaly Detection in Energy Usage, Motion, or Sensor Readings**\n\n"
                "Uses baseline learning to identify anomalies."
            ),
            inputSchema={
                "type": "object",
                "properties": {
                    "entity_id": {
                        "type": "string",
                        "description": "Sensor entity to analyze"
                    },
                    "baseline_days": {
                        "type": "integer",
                        "description": "Days of history for baseline (default: 7)",
                        "default": 7
                    },
                    "sensitivity": {
                        "type": "string",
                        "enum": ["low", "medium", "high"],
                        "description": "Anomaly detection sensitivity",
                        "default": "medium"
                    }
                },
                "required": ["entity_id"]
            }
        ),
        
        Tool(
            name="vacation_mode",
            description=(
                "âœˆï¸ **Vacation Mode with Presence Simulation**\n\n"
                "Activates energy-efficient settings, presence simulation, and automated alerts."
            ),
            inputSchema={
                "type": "object",
                "properties": {
                    "start_date": {"type": "string", "description": "Vacation start (YYYY-MM-DD)"},
                    "end_date": {"type": "string", "description": "Vacation end (YYYY-MM-DD)"},
                    "simulate_presence": {
                        "type": "boolean",
                        "description": "Randomly turn on lights/TVs to simulate occupancy",
                        "default": True
                    },
                    "security_mode": {
                        "type": "string",
                        "enum": ["high", "medium", "low"],
                        "description": "Security alert sensitivity"
                    }
                },
                "required": ["start_date", "end_date"]
            }
        ),
        
        # =================================================================
        # AUTOMATION MANAGEMENT
        # =================================================================
        
        Tool(
            name="list_automations",
            description="ğŸ“‹ List all Home Assistant automations with status and last triggered time.",
            inputSchema={"type": "object", "properties": {}}
        ),
        
        Tool(
            name="trigger_automation",
            description="â–¶ï¸ Manually trigger an automation by entity_id. Useful for testing or manual execution.",
            inputSchema={
                "type": "object",
                "properties": {
                    "entity_id": {"type": "string", "description": "Automation entity ID"}
                },
                "required": ["entity_id"]
            }
        ),
        
        Tool(
            name="enable_disable_automation",
            description="ğŸ”€ Enable or disable an automation. Useful for seasonal automations or troubleshooting.",
            inputSchema={
                "type": "object",
                "properties": {
                    "entity_id": {"type": "string", "description": "Automation entity ID"},
                    "action": {
                        "type": "string",
                        "enum": ["enable", "disable"],
                        "description": "Enable or disable"
                    }
                },
                "required": ["entity_id", "action"]
            }
        ),
        
        Tool(
            name="create_automation",
            description=(
                "â• **Create New Automation from YAML**\n\n"
                "Create sophisticated automations with triggers, conditions, and actions.\n\n"
                "**TRIGGERS:** time, state, numeric_state, sun, event, webhook, etc.\n"
                "**CONDITIONS:** state, numeric_state, time, sun, zone, etc.\n"
                "**ACTIONS:** service calls, scene activation, delays, wait patterns, choose conditions, loops, variables"
            ),
            inputSchema={
                "type": "object",
                "properties": {
                    "alias": {"type": "string", "description": "Automation friendly name"},
                    "trigger": {
                        "type": "array",
                        "description": "List of trigger configurations"
                    },
                    "condition": {
                        "type": "array",
                        "description": "Optional list of conditions"
                    },
                    "action": {
                        "type": "array",
                        "description": "List of actions to execute"
                    },
                    "mode": {
                        "type": "string",
                        "enum": ["single", "restart", "queued", "parallel"],
                        "description": "Automation mode (default: single)",
                        "default": "single"
                    }
                },
                "required": ["alias", "trigger", "action"]
            }
        ),
        
        Tool(
            name="update_automation",
            description="âœï¸ Update existing automation. Change triggers, conditions, or actions without deleting.",
            inputSchema={
                "type": "object",
                "properties": {
                    "entity_id": {"type": "string", "description": "Automation entity ID"},
                    "alias": {"type": "string", "description": "New alias (optional)"},
                    "trigger": {"type": "array", "description": "New triggers (optional)"},
                    "condition": {"type": "array", "description": "New conditions (optional)"},
                    "action": {"type": "array", "description": "New actions (optional)"}
                },
                "required": ["entity_id"]
            }
        ),
        
        Tool(
            name="delete_automation",
            description="ğŸ—‘ï¸ Delete automation from Home Assistant. Use with caution - cannot be undone.",
            inputSchema={
                "type": "object",
                "properties": {
                    "entity_id": {"type": "string", "description": "Automation entity ID to delete"},
                    "confirm": {
                        "type": "boolean",
                        "description": "Confirmation flag (must be true)",
                        "default": False
                    }
                },
                "required": ["entity_id", "confirm"]
            }
        ),
        
        Tool(
            name="get_automation_details",
            description="ğŸ” Get comprehensive details about automation: triggers, conditions, actions, execution history.",
            inputSchema={
                "type": "object",
                "properties": {
                    "entity_id": {"type": "string", "description": "Automation entity ID"}
                },
                "required": ["entity_id"]
            }
        ),
        
        # =================================================================
        # LOGS, HISTORY & TROUBLESHOOTING
        # =================================================================
        
        Tool(
            name="get_entity_history",
            description=(
                "ğŸ“Š **Entity History with State Changes**\n\n"
                "Get historical state changes for any entity to understand past behavior."
            ),
            inputSchema={
                "type": "object",
                "properties": {
                    "entity_id": {"type": "string", "description": "Entity ID to query"},
                    "start_time": {
                        "type": "string",
                        "description": "Start time (ISO format or relative like '-24h')"
                    },
                    "end_time": {
                        "type": "string",
                        "description": "End time (ISO format, default: now)"
                    }
                },
                "required": ["entity_id"]
            }
        ),
        
        Tool(
            name="get_system_logs",
            description=(
                "ğŸ“ **Home Assistant System Logs**\n\n"
                "Retrieve system logs for debugging and monitoring. "
                "Filter by severity (error, warning, info) and search for specific components."
            ),
            inputSchema={
                "type": "object",
                "properties": {
                    "severity": {
                        "type": "string",
                        "enum": ["error", "warning", "info", "debug"],
                        "description": "Minimum severity level"
                    },
                    "component": {
                        "type": "string",
                        "description": "Filter by component (e.g., 'light', 'automation')"
                    },
                    "limit": {
                        "type": "integer",
                        "description": "Max log entries (default: 50)",
                        "default": 50
                    }
                },
            }
        ),
        
        Tool(
            name="get_error_log",
            description=(
                "âŒ **Quick Error Log Summary**\n\n"
                "Get recent errors and warnings from Home Assistant. "
                "Quick way to identify problems without reading full logs."
            ),
            inputSchema={
                "type": "object",
                "properties": {
                    "limit": {
                        "type": "integer",
                        "description": "Number of errors to return (default: 20)",
                        "default": 20
                    }
                }
            }
        ),
        
        Tool(
            name="diagnose_entity",
            description=(
                "ğŸ©º **Comprehensive Entity Diagnostics**\n\n"
                "Deep dive into entity: current state, attributes, recent history, related automations."
            ),
            inputSchema={
                "type": "object",
                "properties": {
                    "entity_id": {"type": "string", "description": "Entity to diagnose"},
                    "include_history": {
                        "type": "boolean",
                        "description": "Include state history (default: true)",
                        "default": True
                    }
                },
                "required": ["entity_id"]
            }
        ),
        
        Tool(
            name="get_statistics",
            description=(
                "ğŸ“ˆ **Statistical Analysis of Sensor Data**\n\n"
                "Get min, max, mean, sum values over time periods for sensors."
            ),
            inputSchema={
                "type": "object",
                "properties": {
                    "entity_id": {"type": "string", "description": "Sensor entity ID"},
                    "period": {
                        "type": "string",
                        "enum": ["hour", "day", "week", "month"],
                        "description": "Statistical period"
                    },
                    "start_time": {"type": "string", "description": "Start time (ISO or relative)"}
                },
                "required": ["entity_id", "period"]
            }
        ),
        
        Tool(
            name="get_binary_sensor",
            description=(
                "ğŸ”˜ **Binary Sensor State Inspector**\n\n"
                "Check binary sensors (door, window, motion, smoke, etc.) with detailed attributes."
            ),
            inputSchema={
                "type": "object",
                "properties": {
                    "entity_id": {"type": "string", "description": "Binary sensor entity ID"},
                    "include_battery": {
                        "type": "boolean",
                        "description": "Include battery info if available",
                        "default": True
                    }
                },
                "required": ["entity_id"]
            }
        ),
        
        Tool(
            name="analyze_patterns",
            description=(
                "ğŸ” **Pattern Analysis for Predictive Automation**\n\n"
                "Analyze usage patterns (when lights are used, when doors open, etc.) for smart scheduling."
            ),
            inputSchema={
                "type": "object",
                "properties": {
                    "entity_id": {"type": "string", "description": "Entity to analyze"},
                    "days": {
                        "type": "integer",
                        "description": "Days of history to analyze (default: 30)",
                        "default": 30
                    },
                    "pattern_type": {
                        "type": "string",
                        "enum": ["hourly", "daily", "weekly"],
                        "description": "Pattern granularity"
                    }
                },
                "required": ["entity_id"]
            }
        ),
        
        # =================================================================
        # SCENE & SCRIPT MANAGEMENT
        # =================================================================
        
        Tool(
            name="activate_scene",
            description=(
                "ğŸ¬ **Activate Predefined Scene**\n\n"
                "Activate a scene to set multiple devices to predefined states instantly.\n\n"
                "**COMMON SCENES:**\n"
                "- Good Morning: Lights on, blinds open, music starts\n"
                "- Movie Time: Dim lights, close blinds, TV on\n"
                "- Dinner: Warm lighting, music\n"
                "- Bedtime: Minimal lighting, cool temp\n"
                "- Away: All off, security armed\n\n"
                "**RELATED TOOLS:** create_automation() to schedule scenes, multi_room_lighting_sync() for coordinated multi-room effects"
            ),
            inputSchema={
                "type": "object",
                "properties": {
                    "entity_id": {"type": "string", "description": "Scene entity ID (e.g., scene.movie_time)"},
                    "transition": {
                        "type": "integer",
                        "description": "Transition time in seconds (optional)"
                    }
                },
                "required": ["entity_id"]
            }
        ),
        
        Tool(
            name="run_script",
            description=(
                "ğŸ­ **Execute Home Assistant Script**\n\n"
                "Run a predefined script - sequences of actions that can include delays, conditions, service calls."
            ),
            inputSchema={
                "type": "object",
                "properties": {
                    "entity_id": {"type": "string", "description": "Script entity ID"},
                    "variables": {
                        "type": "object",
                        "description": "Variables to pass to script"
                    }
                },
                "required": ["entity_id"]
            }
        ),
        
        # =================================================================
        # MULTI-STEP WORKFLOWS
        # =================================================================
        
        Tool(
            name="morning_routine",
            description=(
                "ğŸŒ… **Morning Routine Workflow**\n\n"
                "Gradual wake-up lighting, open blinds, adjust temperature, start coffee maker. Adapts to schedule and weather."
            ),
            inputSchema={
                "type": "object",
                "properties": {
                    "wake_time": {
                        "type": "string",
                        "description": "Wake time (HH:MM format, default: 07:00)",
                        "default": "07:00"
                    },
                    "light_entities": {
                        "type": "array",
                        "items": {"type": "string"},
                        "description": "Lights to include in wake-up routine"
                    },
                    "blind_entities": {
                        "type": "array",
                        "items": {"type": "string"},
                        "description": "Blinds to open"
                    },
                    "climate_entity": {"type": "string", "description": "Thermostat to adjust"}
                }
            }
        ),
        
        Tool(
            name="evening_routine",
            description=(
                "ğŸŒ† **Evening Routine Workflow**\n\n"
                "Dims lights, closes blinds, adjusts temperature, locks doors. Prepares home for night."
            ),
            inputSchema={
                "type": "object",
                "properties": {
                    "start_time": {"type": "string", "description": "Evening routine start (HH:MM)"},
                    "rooms": {
                        "type": "array",
                        "items": {"type": "string"},
                        "description": "Rooms to include"
                    }
                }
            }
        ),
        
        Tool(
            name="bedtime_routine",
            description=(
                "ğŸ˜´ **Bedtime Routine**\n\n"
                "Turns off most lights, activates nightlight, locks doors, lowers thermostat, enables sleep mode."
            ),
            inputSchema={
                "type": "object",
                "properties": {
                    "bedtime": {"type": "string", "description": "Bedtime (HH:MM, default: 22:00)"},
                    "nightlight_entity": {"type": "string", "description": "Nightlight to keep on"},
                    "lock_entities": {
                        "type": "array",
                        "items": {"type": "string"},
                        "description": "Locks to secure"
                    }
                }
            }
        ),
        
        Tool(
            name="arrive_home",
            description=(
                "ğŸ¡ **Arrive Home Workflow**\n\n"
                "Turns on welcoming lights, adjusts temperature, disarms security. Adapts based on time of day."
            ),
            inputSchema={
                "type": "object",
                "properties": {
                    "person_entity": {"type": "string", "description": "Person entity (for tracking)"},
                    "light_scene": {
                        "type": "string",
                        "enum": ["bright", "medium", "dim"],
                        "description": "Lighting preference"
                    }
                }
            }
        ),
        
        Tool(
            name="away_mode",
            description=(
                "ğŸš— **Away Mode Activation**\n\n"
                "Energy-efficient climate, arms security, enables presence simulation if desired."
            ),
            inputSchema={
                "type": "object",
                "properties": {
                    "duration_hours": {
                        "type": "integer",
                        "description": "Expected away duration (hours)"
                    },
                    "simulate_presence": {
                        "type": "boolean",
                        "description": "Randomly activate lights/TVs",
                        "default": False
                    }
                }
            }
        ),
        
        # =================================================================
        # CONTEXT-AWARE INTELLIGENCE
        # =================================================================
        
        Tool(
            name="analyze_home_context",
            description=(
                "ğŸ§  **Analyze Complete Home Context**\n\n"
                "Analyzes current state: occupancy, activity, time of day, weather, energy usage."
            ),
            inputSchema={"type": "object", "properties": {}}
        ),
        
        Tool(
            name="activity_recognition",
            description=(
                "ğŸ‘ï¸ **AI Activity Recognition**\n\n"
                "Infer current activity from sensors, devices, time, and patterns. Detects: sleeping, cooking, working, watching TV, etc."
            ),
            inputSchema={
                "type": "object",
                "properties": {
                    "rooms": {
                        "type": "array",
                        "items": {"type": "string"},
                        "description": "Rooms to analyze"
                    }
                }
            }
        ),
        
        Tool(
            name="comfort_optimization",
            description=(
                "ğŸ’† **Multi-Factor Comfort Optimization**\n\n"
                "Optimizes for comfort: temperature, lighting, air quality, noise level."
            ),
            inputSchema={
                "type": "object",
                "properties": {
                    "room": {"type": "string", "description": "Room to optimize"},
                    "preferences": {
                        "type": "object",
                        "description": "User preferences (temp, brightness, etc.)"
                    }
                }
            }
        ),
        
        Tool(
            name="energy_intelligence",
            description=(
                "âš¡ **Energy Usage Analysis & Optimization**\n\n"
                "Analyzes energy consumption and provides recommendations."
            ),
            inputSchema={
                "type": "object",
                "properties": {
                    "period": {
                        "type": "string",
                        "enum": ["day", "week", "month"],
                        "description": "Analysis period"
                    },
                    "suggest_savings": {
                        "type": "boolean",
                        "description": "Provide energy-saving suggestions",
                        "default": True
                    }
                }
            }
        ),
        
        # =================================================================
        # PREDICTIVE ANALYTICS
        # =================================================================
        
        Tool(
            name="predictive_maintenance",
            description=(
                "ğŸ”§ **Predictive Maintenance Alerts**\n\n"
                "Predicts device failures based on usage patterns, age, sensor readings."
            ),
            inputSchema={
                "type": "object",
                "properties": {
                    "device_types": {
                        "type": "array",
                        "items": {"type": "string"},
                        "description": "Device types to analyze (HVAC, lights, etc.)"
                    }
                }
            }
        ),
        
        Tool(
            name="weather_integration",
            description=(
                "ğŸŒ¤ï¸ **Weather-Based Automation**\n\n"
                "Takes actions based on weather: close windows before rain, adjust HVAC, etc."
            ),
            inputSchema={
                "type": "object",
                "properties": {
                    "weather_entity": {"type": "string", "description": "Weather sensor entity"},
                    "actions": {
                        "type": "array",
                        "description": "Automated actions based on weather"
                    }
                }
            }
        ),
        
        Tool(
            name="pattern_learning",
            description=(
                "ğŸ“š **Learn User Behavior Patterns**\n\n"
                "Learns daily routines, preferred settings, habitual behaviors for automation suggestions."
            ),
            inputSchema={
                "type": "object",
                "properties": {
                    "entity_ids": {
                        "type": "array",
                        "items": {"type": "string"},
                        "description": "Entities to learn patterns from"
                    },
                    "training_days": {
                        "type": "integer",
                        "description": "Days of history to analyze (default: 30)",
                        "default": 30
                    }
                }
            }
        ),
        
        # =================================================================
        # WHOLE-HOME COORDINATION
        # =================================================================
        
        Tool(
            name="synchronized_home_state",
            description=(
                "ğŸ˜ï¸ **Whole-Home State Coordination**\n\n"
                "Coordinate all devices for unified home state: movie night, dinner party, relaxation, work-from-home."
            ),
            inputSchema={
                "type": "object",
                "properties": {
                    "state": {
                        "type": "string",
                        "enum": ["movie", "dinner", "party", "work", "relax", "sleep", "wake"],
                        "description": "Whole-home state to activate"
                    },
                    "rooms": {
                        "type": "array",
                        "items": {"type": "string"},
                        "description": "Rooms to coordinate (default: all)"
                    }
                },
                "required": ["state"]
            }
        ),
        
        Tool(
            name="follow_me_home",
            description=(
                "ğŸš¶ **Follow Me Automation**\n\n"
                "Follows user movement: lights/climate adjust as you enter rooms, optimize energy in vacant rooms."
            ),
            inputSchema={
                "type": "object",
                "properties": {
                    "person_entity": {"type": "string", "description": "Person to track"},
                    "mode": {
                        "type": "string",
                        "enum": ["lights_only", "climate_only", "full"],
                        "description": "What to adjust"
                    }
                },
                "required": ["person_entity"]
            }
        ),
        
        Tool(
            name="guest_mode",
            description=(
                "ğŸ **Guest Mode Activation**\n\n"
                "Adjusts home for guests: guest room climate, accessible controls, welcoming atmosphere."
            ),
            inputSchema={
                "type": "object",
                "properties": {
                    "guest_rooms": {
                        "type": "array",
                        "items": {"type": "string"},
                        "description": "Rooms for guests"
                    },
                    "arrival_time": {"type": "string", "description": "Guest arrival time"}
                }
            }
        ),
        
        Tool(
            name="movie_mode",
            description=(
                "ğŸ¬ **Cinema Mode**\n\n"
                "Dims lights, closes blinds, optimizes TV/audio, silences notifications."
            ),
            inputSchema={
                "type": "object",
                "properties": {
                    "room": {"type": "string", "description": "Room with TV/projector"},
                    "media_player": {"type": "string", "description": "Media player entity"},
                    "light_level": {
                        "type": "integer",
                        "description": "Ambient light brightness (0-100)",
                        "default": 10
                    }
                }
            }
        ),
    ]


# ============================================================================
# PART 2: TOOL HANDLERS (to add to call_tool() in server.py)
# ============================================================================



def get_part3_dashboard_tools() -> list[Tool]:
    """
    Returns Part 3 dashboard management tool definitions
    Copy these into the main list_tools() function
    """
    return [
        # =================================================================
        # DASHBOARD DISCOVERY & LISTING
        # =================================================================
        
        Tool(
            name="list_dashboards",
            description=(
                "ğŸ“± **List All Home Assistant Dashboards**\n\n"
                "Shows dashboard names, URLs, and configuration modes (storage/yaml). "
                "WHEN TO USE: To see available dashboards before adding/editing cards. "
                "First step in dashboard management."
            ),
            inputSchema={
                "type": "object",
                "properties": {},
                "required": []
            }
        ),
        
        Tool(
            name="discover_dashboards",
            description=(
                "ğŸ” **Enhanced Dashboard Discovery**\n\n"
                "List all dashboards with IDs, titles, and metadata. Filter by type. "
                "WHEN TO USE: To explore available dashboards with detailed information.\n\n"
                "**EXAMPLES:**\n"
                "â€¢ 'Show all dashboards' â†’ discover_dashboards()\n"
                "â€¢ 'List mobile views' â†’ discover_dashboards(dashboard_type='mobile')\n"
                "â€¢ 'Show panel views' â†’ discover_dashboards(dashboard_type='panel')"
            ),
            inputSchema={
                "type": "object",
                "properties": {
                    "dashboard_type": {
                        "type": "string",
                        "enum": ["all", "mobile", "desktop", "panel", "storage", "yaml"],
                        "description": "Filter by type: all, mobile, desktop, panel, storage, yaml"
                    },
                    "include_cards": {
                        "type": "boolean",
                        "description": "Include card count for each dashboard",
                        "default": False
                    }
                },
                "required": []
            }
        ),
        
        # =================================================================
        # HACS CUSTOM CARDS
        # =================================================================
        
        Tool(
            name="list_hacs_cards",
            description=(
                "ğŸ“¦ **List Installed HACS Custom Cards**\n\n"
                "Shows what custom cards are available for dashboard creation. "
                "WHEN TO USE: Before creating custom cards, to verify installation.\n\n"
                "**COMMON HACS CARDS:**\n"
                "â€¢ button-card - Highly customizable buttons\n"
                "â€¢ mushroom - Modern minimalist cards\n"
                "â€¢ mini-graph-card - Compact graphs\n"
                "â€¢ stack-in-card - Card stacking/grouping"
            ),
            inputSchema={
                "type": "object",
                "properties": {},
                "required": []
            }
        ),
        
        Tool(
            name="create_button_card",
            description=(
                "ğŸ¨ **HACS Button-Card Creation**\n\n"
                "Create customizable button-card (most popular HACS card). "
                "Highly flexible with custom colors, icons, tap actions.\n\n"
                "**EXAMPLES:**\n"
                "â€¢ Simple: 'Add button for bedroom light' â†’ create_button_card(dashboard='mobile', entity_id='light.bedroom')\n"
                "â€¢ Advanced: 'Yellow moon button' â†’ create_button_card(entity_id='light.bedroom', color='yellow', icon='mdi:weather-night')\n\n"
                "**FEATURES:** Custom colors, MDI icons, tap actions, show/hide state\n"
                "**REQUIRES:** button-card from HACS"
            ),
            inputSchema={
                "type": "object",
                "properties": {
                    "dashboard": {
                        "type": "string",
                        "description": "Dashboard name (default, mobile, etc.)",
                        "default": "lovelace"
                    },
                    "entity_id": {
                        "type": "string",
                        "description": "Entity to control (light.*, switch.*, scene.*, script.*)"
                    },
                    "name": {
                        "type": "string",
                        "description": "Button display name (optional)"
                    },
                    "icon": {
                        "type": "string",
                        "description": "MDI icon (mdi:lightbulb, mdi:power, etc.)"
                    },
                    "color": {
                        "type": "string",
                        "description": "CSS color (yellow, #FFD700, etc.)",
                        "default": "auto"
                    },
                    "tap_action": {
                        "type": "string",
                        "enum": ["toggle", "more-info", "call-service", "navigate", "none"],
                        "description": "Action when tapped",
                        "default": "toggle"
                    },
                    "show_state": {
                        "type": "boolean",
                        "description": "Show entity state",
                        "default": True
                    },
                    "show_name": {
                        "type": "boolean",
                        "description": "Show entity name",
                        "default": True
                    }
                },
                "required": ["entity_id"]
            }
        ),
        
        Tool(
            name="create_mushroom_card",
            description=(
                "ğŸ„ **HACS Mushroom Card Creation**\n\n"
                "Create modern, minimalist mushroom-card. iOS-inspired design with rounded corners.\n\n"
                "**EXAMPLES:**\n"
                "â€¢ Simple: 'Add mushroom light card' â†’ create_mushroom_card(card_type='light', entity_id='light.bedroom')\n"
                "â€¢ Advanced: 'Mushroom climate card' â†’ create_mushroom_card(card_type='climate', entity_id='climate.living_room', fill_container=true)\n\n"
                "**CARD TYPES:** light, switch, climate, cover, person, entity\n"
                "**REQUIRES:** mushroom from HACS"
            ),
            inputSchema={
                "type": "object",
                "properties": {
                    "dashboard": {
                        "type": "string",
                        "description": "Dashboard name",
                        "default": "lovelace"
                    },
                    "card_type": {
                        "type": "string",
                        "enum": ["light", "switch", "climate", "cover", "person", "entity"],
                        "description": "Mushroom card type"
                    },
                    "entity_id": {
                        "type": "string",
                        "description": "Entity to display/control"
                    },
                    "name": {
                        "type": "string",
                        "description": "Custom name override"
                    },
                    "icon": {
                        "type": "string",
                        "description": "Custom MDI icon"
                    },
                    "fill_container": {
                        "type": "boolean",
                        "description": "Fill container width",
                        "default": False
                    },
                    "show_temperature_control": {
                        "type": "boolean",
                        "description": "For climate: show temp slider",
                        "default": True
                    },
                    "layout": {
                        "type": "string",
                        "enum": ["horizontal", "vertical"],
                        "description": "Card layout",
                        "default": "horizontal"
                    }
                },
                "required": ["card_type", "entity_id"]
            }
        ),
        
        # =================================================================
        # STANDARD DASHBOARD CARDS
        # =================================================================
        
        Tool(
            name="create_dashboard_card",
            description=(
                "ğŸ“‹ **Standard Dashboard Card Creation**\n\n"
                "Create built-in Home Assistant card types (entities, glance, button, gauge, etc.).\n\n"
                "**EXAMPLES:**\n"
                "â€¢ Entities: 'Add bedroom lights card' â†’ create_dashboard_card(card_type='entities', entities=['light.bedroom', 'light.bedside'])\n"
                "â€¢ Gauge: 'Add temp gauge' â†’ create_dashboard_card(card_type='gauge', entity='sensor.temp', min=15, max=30)\n\n"
                "**CARD TYPES:** entities, glance, button, gauge, light, thermostat, picture-entity, history-graph"
            ),
            inputSchema={
                "type": "object",
                "properties": {
                    "dashboard": {
                        "type": "string",
                        "description": "Dashboard name",
                        "default": "lovelace"
                    },
                    "card_type": {
                        "type": "string",
                        "enum": ["entities", "glance", "button", "gauge", "light", "thermostat", "picture-entity", "history-graph", "sensor", "weather-forecast"],
                        "description": "Standard Lovelace card type"
                    },
                    "entity": {
                        "type": "string",
                        "description": "Single entity for single-entity cards"
                    },
                    "entities": {
                        "type": "array",
                        "items": {"type": "string"},
                        "description": "List of entities for multi-entity cards"
                    },
                    "title": {
                        "type": "string",
                        "description": "Card title"
                    },
                    "name": {
                        "type": "string",
                        "description": "Entity display name override"
                    },
                    "icon": {
                        "type": "string",
                        "description": "Custom MDI icon"
                    },
                    "min": {
                        "type": "number",
                        "description": "Gauge minimum value"
                    },
                    "max": {
                        "type": "number",
                        "description": "Gauge maximum value"
                    }
                },
                "required": ["card_type"]
            }
        ),
        
        # =================================================================
        # CARD EDITING & DELETION
        # =================================================================
        
        Tool(
            name="edit_dashboard_card",
            description=(
                "âœï¸ **Edit Existing Dashboard Card**\n\n"
                "Modify card properties (colors, icons, name, tap actions). "
                "Works with standard and custom HACS cards.\n\n"
                "**EXAMPLES:**\n"
                "â€¢ 'Change bedroom button to yellow' â†’ edit_dashboard_card(card_index=0, color='yellow')\n"
                "â€¢ 'Update icon to moon' â†’ edit_dashboard_card(card_index=2, icon='mdi:weather-night')\n\n"
                "**CARD INDEX:** Cards numbered from 0. Use get_dashboard_config() to find indices."
            ),
            inputSchema={
                "type": "object",
                "properties": {
                    "dashboard": {
                        "type": "string",
                        "description": "Dashboard name",
                        "default": "lovelace"
                    },
                    "card_index": {
                        "type": "integer",
                        "description": "Card position (0-based)"
                    },
                    "color": {
                        "type": "string",
                        "description": "New card color"
                    },
                    "icon": {
                        "type": "string",
                        "description": "New MDI icon"
                    },
                    "name": {
                        "type": "string",
                        "description": "New display name"
                    },
                    "entity_id": {
                        "type": "string",
                        "description": "New entity to control"
                    },
                    "tap_action": {
                        "type": "string",
                        "enum": ["toggle", "more-info", "call-service", "navigate", "none"],
                        "description": "New tap action"
                    },
                    "show_state": {
                        "type": "boolean",
                        "description": "Show/hide state"
                    },
                    "show_name": {
                        "type": "boolean",
                        "description": "Show/hide name"
                    }
                },
                "required": ["card_index"]
            }
        ),
        
        Tool(
            name="delete_dashboard_card",
            description=(
                "ğŸ—‘ï¸ **Delete Dashboard Card**\n\n"
                "Remove card from dashboard by index. Permanent deletion.\n\n"
                "**EXAMPLES:**\n"
                "â€¢ 'Remove first card' â†’ delete_dashboard_card(card_index=0)\n"
                "â€¢ 'Delete bedroom button' â†’ delete_dashboard_card(card_index=5)\n\n"
                "âš ï¸ **WARNING:** Deletion is permanent. Use get_dashboard_config() first to verify."
            ),
            inputSchema={
                "type": "object",
                "properties": {
                    "dashboard": {
                        "type": "string",
                        "description": "Dashboard name",
                        "default": "lovelace"
                    },
                    "card_index": {
                        "type": "integer",
                        "description": "Card position to delete (0-based)"
                    }
                },
                "required": ["card_index"]
            }
        ),
        
        # =================================================================
        # DASHBOARD INSPECTION
        # =================================================================
        
        Tool(
            name="get_dashboard_config",
            description=(
                "ğŸ” **Inspect Dashboard Configuration**\n\n"
                "Retrieve complete dashboard config: all cards, views, settings. "
                "Shows card index positions for editing/deletion.\n\n"
                "**EXAMPLES:**\n"
                "â€¢ 'Show mobile dashboard cards' â†’ get_dashboard_config(dashboard='mobile')\n"
                "â€¢ 'What's card 3?' â†’ get_dashboard_config() then find index 3\n\n"
                "**RETURNS:** Dashboard title, mode, all cards with indices, card properties"
            ),
            inputSchema={
                "type": "object",
                "properties": {
                    "dashboard": {
                        "type": "string",
                        "description": "Dashboard name to inspect",
                        "default": "lovelace"
                    }
                },
                "required": []
            }
        ),
        
        Tool(
            name="get_dashboard_card",
            description=(
                "ğŸ” **Get Single Card Details**\n\n"
                "Retrieve detailed configuration of specific card by index or ID.\n\n"
                "**EXAMPLES:**\n"
                "â€¢ 'Show kitchen energy card' â†’ get_dashboard_card(dashboard_id='kitchen', card_index=2)\n"
                "â€¢ 'Check weather card' â†’ get_dashboard_card(card_index=0)\n"
                "â€¢ 'List all cards' â†’ get_dashboard_card(list_all=true)"
            ),
            inputSchema={
                "type": "object",
                "properties": {
                    "dashboard_id": {
                        "type": "string",
                        "description": "Dashboard identifier",
                        "default": "lovelace"
                    },
                    "card_index": {
                        "type": "integer",
                        "description": "Card position (0-based)"
                    },
                    "card_id": {
                        "type": "string",
                        "description": "Card identifier (alternative to index)"
                    },
                    "list_all": {
                        "type": "boolean",
                        "description": "List all cards with indices",
                        "default": False
                    }
                },
                "required": []
            }
        ),
    ]


# ============================================================================
# PART 3: DASHBOARD TOOL HANDLERS (to add to call_tool() in server.py)
# ============================================================================



# ============================================================================
# TOOL HANDLERS FROM CONVERTED PARTS
# ============================================================================










@app.list_tools()
async def list_tools() -> list[Tool]:
    """List all available tools"""
    
    return [
        # ===================================================================
        # CONVERTED TOOLS FROM PART 1: Discovery, Control, Lighting, Media, Climate
        # ===================================================================
        *get_part1_tools(),
        
        # ===================================================================
        # CONVERTED TOOLS FROM PART 2: Security, Automation, Workflows, Intelligence
        # ===================================================================
        *get_part2_tools(),
        
        # ===================================================================
        # CONVERTED TOOLS FROM PART 3: Dashboard & HACS Management
        # ===================================================================
        *get_part3_dashboard_tools(),
        
        # ===================================================================
        # CODE EXECUTION & DATA ANALYSIS TOOLS (NEW!)
        # ===================================================================
        
        Tool(
            name="execute_python",
            description="Execute Python code with access to pandas, matplotlib, numpy, seaborn. Perfect for analyzing Home Assistant data. Code runs in a safe sandbox. Can return print() output and matplotlib plots as base64 images.",
            inputSchema={
                "type": "object",
                "properties": {
                    "code": {
                        "type": "string",
                        "description": "Python code to execute. Available imports: pandas as pd, numpy as np, matplotlib.pyplot as plt, seaborn as sns"
                    },
                    "return_stdout": {
                        "type": "boolean",
                        "description": "Return print() output (default: true)",
                        "default": True
                    },
                    "return_plots": {
                        "type": "boolean",
                        "description": "Return matplotlib plots as base64 PNG images (default: true)",
                        "default": True
                    }
                },
                "required": ["code"]
            }
        ),
        
        Tool(
            name="analyze_states_dataframe",
            description="Get Home Assistant entity states as a pandas DataFrame for instant analysis. Returns entities with all their attributes in a structured format ready for pandas queries, grouping, filtering, etc.",
            inputSchema={
                "type": "object",
                "properties": {
                    "domain": {
                        "type": "string",
                        "description": "Filter by domain (e.g., 'light', 'sensor', 'switch'). Leave empty for all domains."
                    },
                    "include_attributes": {
                        "type": "boolean",
                        "description": "Include all entity attributes as columns (default: true)",
                        "default": True
                    },
                    "query": {
                        "type": "string",
                        "description": "Pandas query string to filter results (e.g., \"state == 'on'\" or \"entity_id.str.contains('temp')\")"
                    }
                }
            }
        ),
        
        Tool(
            name="plot_sensor_history",
            description="Plot sensor history as a time-series chart. Returns matplotlib visualization as base64 PNG. Perfect for temperature trends, power consumption, etc.",
            inputSchema={
                "type": "object",
                "properties": {
                    "entity_ids": {
                        "type": "array",
                        "items": {"type": "string"},
                        "description": "List of entity IDs to plot (e.g., ['sensor.temperature', 'sensor.humidity'])"
                    },
                    "hours": {
                        "type": "number",
                        "description": "Hours of history to plot (default: 24)",
                        "default": 24
                    },
                    "chart_type": {
                        "type": "string",
                        "enum": ["line", "bar", "scatter"],
                        "description": "Type of chart (default: 'line')",
                        "default": "line"
                    },
                    "title": {
                        "type": "string",
                        "description": "Chart title (auto-generated if not provided)"
                    }
                },
                "required": ["entity_ids"]
            }
        ),
        
        # ===================================================================
        # ORIGINAL NATIVE ADD-ON TOOLS (File & API Operations)
        # ===================================================================

        # File System Tools
        Tool(
            name="read_file",
            description="Read file content from Home Assistant config directory. Direct file system access - no SSH needed!",
            inputSchema={
                "type": "object",
                "properties": {
                    "filepath": {
                        "type": "string",
                        "description": "Relative path from /config (e.g., 'packages/kitchen.yaml')"
                    }
                },
                "required": ["filepath"]
            }
        ),
        
        Tool(
            name="write_file",
            description="Write or update file in Home Assistant config directory. Creates backup automatically.",
            inputSchema={
                "type": "object",
                "properties": {
                    "filepath": {"type": "string", "description": "Relative path from /config"},
                    "content": {"type": "string", "description": "File content"},
                    "create_backup": {"type": "boolean", "description": "Create backup (default: true)", "default": True}
                },
                "required": ["filepath", "content"]
            }
        ),
        
        Tool(
            name="list_directory",
            description="List files and directories",
            inputSchema={
                "type": "object",
                "properties": {
                    "dirpath": {"type": "string", "description": "Directory path (default: '.')", "default": "."}
                }
            }
        ),
        
        Tool(
            name="get_directory_tree",
            description="Get recursive directory tree structure",
            inputSchema={
                "type": "object",
                "properties": {
                    "dirpath": {"type": "string", "description": "Starting directory", "default": "."},
                    "max_depth": {"type": "integer", "description": "Maximum recursion depth", "default": 5}
                }
            }
        ),
        
        Tool(
            name="create_directory",
            description="Create new directory",
            inputSchema={
                "type": "object",
                "properties": {
                    "dirpath": {"type": "string", "description": "Directory path to create"}
                },
                "required": ["dirpath"]
            }
        ),
        
        Tool(
            name="delete_file",
            description="Delete file or directory",
            inputSchema={
                "type": "object",
                "properties": {
                    "filepath": {"type": "string", "description": "Path to delete"}
                },
                "required": ["filepath"]
            }
        ),
        
        Tool(
            name="move_file",
            description="Move or rename file/directory",
            inputSchema={
                "type": "object",
                "properties": {
                    "source": {"type": "string", "description": "Source path"},
                    "destination": {"type": "string", "description": "Destination path"}
                },
                "required": ["source", "destination"]
            }
        ),
        
        Tool(
            name="copy_file",
            description="Copy file or directory",
            inputSchema={
                "type": "object",
                "properties": {
                    "source": {"type": "string", "description": "Source path"},
                    "destination": {"type": "string", "description": "Destination path"}
                },
                "required": ["source", "destination"]
            }
        ),
        
        Tool(
            name="search_files",
            description="Search files by content pattern",
            inputSchema={
                "type": "object",
                "properties": {
                    "pattern": {"type": "string", "description": "Search pattern"},
                    "directory": {"type": "string", "description": "Directory to search", "default": "."},
                    "extensions": {"type": "array", "items": {"type": "string"}, "description": "File extensions to search"}
                },
                "required": ["pattern"]
            }
        ),
        
        # Home Assistant API Tools
        Tool(
            name="get_states",
            description="Get Home Assistant entity states with optional filtering and pagination",
            inputSchema={
                "type": "object",
                "properties": {
                    "domain": {
                        "type": "string",
                        "description": "Filter by domain (e.g., 'light', 'switch', 'sensor'). Optional."
                    },
                    "entity_id_pattern": {
                        "type": "string",
                        "description": "Filter by entity ID pattern (regex). Optional."
                    },
                    "limit": {
                        "type": "integer",
                        "description": "Maximum number of entities to return (default: 50, max: 500)",
                        "default": 50
                    },
                    "offset": {
                        "type": "integer",
                        "description": "Number of entities to skip for pagination (default: 0)",
                        "default": 0
                    }
                }
            }
        ),
        
        Tool(
            name="get_state",
            description="Get specific entity state",
            inputSchema={
                "type": "object",
                "properties": {
                    "entity_id": {"type": "string", "description": "Entity ID (e.g., 'light.kitchen')"}
                },
                "required": ["entity_id"]
            }
        ),
        
        Tool(
            name="call_service",
            description="Call Home Assistant service",
            inputSchema={
                "type": "object",
                "properties": {
                    "domain": {"type": "string", "description": "Service domain (e.g., 'light')"},
                    "service": {"type": "string", "description": "Service name (e.g., 'turn_on')"},
                    "entity_id": {"type": "string", "description": "Target entity ID"},
                    "data": {"type": "object", "description": "Service data"}
                },
                "required": ["domain", "service"]
            }
        ),
    ]


@app.call_tool()
async def call_tool(name: str, arguments: dict) -> list[TextContent]:
    """Handle tool calls"""
    
    try:
        # File System Operations
        if name == "read_file":
            content = await file_mgr.read_file(arguments["filepath"])
            return [TextContent(type="text", text=content)]
        
        elif name == "write_file":
            result = await file_mgr.write_file(
                arguments["filepath"],
                arguments["content"],
                arguments.get("create_backup", True)
            )
            return [TextContent(type="text", text=result)]
        
        elif name == "list_directory":
            items = await file_mgr.list_directory(arguments.get("dirpath", "."))
            return [TextContent(type="text", text=json.dumps(items, indent=2))]
        
        elif name == "get_directory_tree":
            tree = await file_mgr.get_directory_tree(
                arguments.get("dirpath", "."),
                arguments.get("max_depth", 5)
            )
            return [TextContent(type="text", text=json.dumps(tree, indent=2))]
        
        elif name == "create_directory":
            result = await file_mgr.create_directory(arguments["dirpath"])
            return [TextContent(type="text", text=result)]
        
        elif name == "delete_file":
            result = await file_mgr.delete_file(arguments["filepath"])
            return [TextContent(type="text", text=result)]
        
        elif name == "move_file":
            result = await file_mgr.move_file(arguments["source"], arguments["destination"])
            return [TextContent(type="text", text=result)]
        
        elif name == "copy_file":
            result = await file_mgr.copy_file(arguments["source"], arguments["destination"])
            return [TextContent(type="text", text=result)]
        
        elif name == "search_files":
            matches = await file_mgr.search_files(
                arguments["pattern"],
                arguments.get("directory", "."),
                arguments.get("extensions")
            )
            return [TextContent(type="text", text=json.dumps(matches, indent=2))]
        
        # Home Assistant API Operations
        elif name == "get_states":
            # Get all states from HA
            all_states = await ha_api.get_states()
            
            # Apply filtering
            filtered_states = all_states
            
            # Filter by domain if specified
            if "domain" in arguments and arguments["domain"]:
                domain = arguments["domain"].lower()
                filtered_states = [
                    state for state in filtered_states 
                    if state.get("entity_id", "").startswith(f"{domain}.")
                ]
            
            # Filter by entity_id pattern if specified
            if "entity_id_pattern" in arguments and arguments["entity_id_pattern"]:
                import re
                pattern = re.compile(arguments["entity_id_pattern"], re.IGNORECASE)
                filtered_states = [
                    state for state in filtered_states
                    if pattern.search(state.get("entity_id", ""))
                ]
            
            # Apply pagination
            offset = arguments.get("offset", 0)
            limit = min(arguments.get("limit", 50), 500)  # Max 500 entities
            
            total_count = len(filtered_states)
            paginated_states = filtered_states[offset:offset + limit]
            
            # Build response with metadata
            response = {
                "states": paginated_states,
                "metadata": {
                    "total": total_count,
                    "returned": len(paginated_states),
                    "offset": offset,
                    "limit": limit,
                    "has_more": (offset + limit) < total_count
                }
            }
            
            return [TextContent(type="text", text=json.dumps(response, indent=2, default=str))]
        
        elif name == "get_state":
            state = await ha_api.get_state(arguments["entity_id"])
            return [TextContent(type="text", text=json.dumps(state, indent=2))]
        
        elif name == "call_service":
            service_data = arguments.get("data", {})
            if "entity_id" in arguments:
                service_data["entity_id"] = arguments["entity_id"]
            
            result = await ha_api.call_service(
                arguments["domain"],
                arguments["service"],
                service_data
            )
            return [TextContent(type="text", text=json.dumps(result, indent=2))]
        
        # ===================================================================
        # CODE EXECUTION & DATA ANALYSIS TOOL HANDLERS (NEW!)
        # ===================================================================
        elif name == "execute_python":
            result = await execute_python_code(
                arguments["code"],
                return_stdout=arguments.get("return_stdout", True),
                return_plots=arguments.get("return_plots", True)
            )
            return [TextContent(type="text", text=result)]
        
        elif name == "analyze_states_dataframe":
            result = await analyze_states_as_dataframe(
                ha_api,
                domain=arguments.get("domain"),
                include_attributes=arguments.get("include_attributes", True),
                query=arguments.get("query")
            )
            return [TextContent(type="text", text=result)]
        
        elif name == "plot_sensor_history":
            result = await plot_sensor_history_chart(
                ha_api,
                entity_ids=arguments["entity_ids"],
                hours=arguments.get("hours", 24),
                chart_type=arguments.get("chart_type", "line"),
                title=arguments.get("title")
            )
            return [TextContent(type="text", text=result)]
        
        # ===================================================================
        # CONVERTED TOOL HANDLERS - Try all three parts
        # ===================================================================
        else:
            # Try Part 1 handlers
            result = await handle_part1_tools(name, arguments, ha_api, file_mgr)
            if result is not None:
                return result
            
            # Try Part 2 handlers
            result = await handle_part2_tools(name, arguments, ha_api, file_mgr)
            if result is not None:
                return result
            
            # Try Part 3 handlers
            result = await handle_part3_dashboard_tools(name, arguments, ha_api, file_mgr)
            if result is not None:
                return result
            
            # Unknown tool - none of the handlers recognized it
            raise ValueError(f"Unknown tool: {name}")
    
    except Exception as e:
        logger.error(f"Tool execution failed: {e}", exc_info=True)
        return [TextContent(type="text", text=f"Error: {str(e)}")]


async def main():
    """Run the MCP server as HTTP server"""
    from mcp.server.sse import SseServerTransport
    from starlette.applications import Starlette
    from starlette.routing import Mount
    from starlette.responses import JSONResponse
    import uvicorn
    
    logger.info("ğŸš€ Starting Home Assistant MCP Server (Native Add-on)")
    logger.info(f"ğŸ“ Config access: {HA_CONFIG_PATH}")
    logger.info(f"ğŸ”Œ Listening on port {PORT}")
    logger.info("âœ… Direct file system access - NO SSH/SFTP needed!")
    
    # Create SSE transport for HTTP-based MCP
    sse = SseServerTransport("/messages")
    
    # Health check endpoint
    async def health_check(request):
        return JSONResponse({
            "status": "healthy",
            "service": "ha-mcp-server",
            "version": "1.0.0"
        })
    
    # Favicon endpoint to eliminate 404 errors
    async def favicon(request):
        from starlette.responses import Response
        # Return a simple 1x1 transparent PNG
        favicon_data = bytes.fromhex(
            "89504e470d0a1a0a0000000d494844520000000100000001"
            "08060000001f15c4890000000a49444154789c6300010000"
            "00050001edd2462e0000000049454e44ae426082"
        )
        return Response(content=favicon_data, media_type="image/png")
    
    # Create ASGI app for SSE handling
    async def handle_sse_message(scope, receive, send):
        from starlette.responses import Response
        if scope["type"] == "http":
            if scope["method"] == "GET":
                async with sse.connect_sse(scope, receive, send) as streams:
                    await app.run(
                        streams[0],
                        streams[1],
                        app.create_initialization_options()
                    )
                return Response(status_code=200)
            elif scope["method"] == "POST":
                await sse.handle_post_message(scope, receive, send)
                return Response(status_code=202)
        # Fallback for unexpected requests
        return Response(status_code=405, content="Method Not Allowed")
    
    # Create Starlette app
    from starlette.routing import Route
    web_app = Starlette(
        routes=[
            Mount("/messages", app=handle_sse_message),
            Route("/health", endpoint=health_check),
            Route("/favicon.ico", endpoint=favicon),
        ]
    )
    
    # Run HTTP server
    logger.info(f"ğŸŒ HTTP server starting on 0.0.0.0:{PORT}")
    config = uvicorn.Config(
        web_app,
        host="0.0.0.0",
        port=PORT,
        log_level="info"
    )
    server = uvicorn.Server(config)
    await server.serve()


if __name__ == "__main__":
    asyncio.run(main())


