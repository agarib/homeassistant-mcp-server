# v4.0.7 WebSocket Implementation Plan

**Date:** November 8, 2025 (Tomorrow)  
**Goal:** Full WebSocket support for 10 dashboard tools  
**Current Version:** v4.0.6 RC1 (95 endpoints, 85 working)  
**Target Version:** v4.0.7 (95 endpoints, 95 working = 100%)

---

## üìã Executive Summary

**Objective:** Implement WebSocket client to enable the 10 dashboard/Lovelace tools that currently return 404 errors.

**Why WebSocket?**

- Official HA API documentation confirms: Dashboard/Lovelace management is **WebSocket-only**
- No REST API endpoints exist for `/api/lovelace/*`
- Dashboard operations require real-time bidirectional communication

**Impact:**

- **Before:** 85/95 tools working (89%)
- **After:** 95/95 tools working (100%) ‚ú®

**Estimated Time:** 4-6 hours

---

## üéØ Goals for Tomorrow

### Primary Goals

1. ‚úÖ Add `websockets` Python dependency
2. ‚úÖ Implement WebSocket client class
3. ‚úÖ Update 10 dashboard/card tools to use WebSocket
4. ‚úÖ Test all dashboard operations
5. ‚úÖ Deploy v4.0.7 to production
6. ‚úÖ Achieve 100% tool success rate

### Stretch Goals

7. üåü Add real-time event subscription (bonus)
8. üåü Add automation validation via WebSocket (bonus)
9. üåü Create WebSocket monitoring dashboard (bonus)

---

## üîß Implementation Steps

### Phase 1: Setup & Dependencies (30 minutes)

#### Step 1.1: Update Requirements

```bash
# Add to requirements.txt
websockets>=12.0
```

#### Step 1.2: Test WebSocket Connection

```python
# Quick test script
import asyncio
import websockets
import json

async def test_ha_websocket():
    async with websockets.connect("ws://192.168.1.203:8123/api/websocket") as ws:
        # Receive auth_required
        msg = await ws.recv()
        print(f"Auth required: {msg}")

        # Send auth with SUPERVISOR_TOKEN
        await ws.send(json.dumps({
            "type": "auth",
            "access_token": "YOUR_SUPERVISOR_TOKEN"
        }))

        # Receive auth_ok
        auth_result = await ws.recv()
        print(f"Auth result: {auth_result}")

asyncio.run(test_ha_websocket())
```

**Expected Output:**

```json
{"type": "auth_required", "ha_version": "2025.11.0"}
{"type": "auth_ok", "ha_version": "2025.11.0"}
```

---

### Phase 2: WebSocket Client Implementation (1-2 hours)

#### Step 2.1: Create WebSocket Client Class

**File:** `server.py` (add before endpoints)

```python
# ============================================================================
# WEBSOCKET CLIENT FOR DASHBOARD OPERATIONS
# ============================================================================
# Based on official Home Assistant WebSocket API documentation (Oct 2025)
# https://developers.home-assistant.io/docs/api/websocket

import websockets
import json
import asyncio
from typing import Optional, Dict, Any

class HomeAssistantWebSocket:
    """
    WebSocket client for Home Assistant dashboard operations.
    Handles authentication, message passing, and connection lifecycle.
    """

    def __init__(self, url: str, token: str):
        """
        Initialize WebSocket client.

        Args:
            url: HA URL (e.g., "http://supervisor/core")
            token: SUPERVISOR_TOKEN or long-lived access token
        """
        # Convert HTTP URL to WebSocket URL
        self.ws_url = url.replace("http://", "ws://").replace("https://", "wss://")
        self.ws_url = f"{self.ws_url}/api/websocket"
        self.token = token
        self.ws = None
        self.msg_id = 1
        self._lock = asyncio.Lock()

    async def connect(self) -> bool:
        """
        Establish WebSocket connection and authenticate.

        Returns:
            bool: True if connected and authenticated
        """
        try:
            # Connect to WebSocket
            self.ws = await websockets.connect(
                self.ws_url,
                ping_interval=20,
                ping_timeout=10
            )

            # Step 1: Receive auth_required message
            auth_required = await self.ws.recv()
            auth_msg = json.loads(auth_required)

            if auth_msg.get("type") != "auth_required":
                raise Exception(f"Expected auth_required, got: {auth_msg}")

            logger.info(f"WebSocket auth required, HA version: {auth_msg.get('ha_version')}")

            # Step 2: Send authentication
            await self.ws.send(json.dumps({
                "type": "auth",
                "access_token": self.token
            }))

            # Step 3: Receive auth result
            auth_result = await self.ws.recv()
            result_msg = json.loads(auth_result)

            if result_msg.get("type") == "auth_ok":
                logger.info("‚úÖ WebSocket authenticated successfully")
                return True
            else:
                logger.error(f"‚ùå WebSocket authentication failed: {result_msg}")
                return False

        except Exception as e:
            logger.error(f"WebSocket connection error: {e}", exc_info=True)
            if self.ws:
                await self.ws.close()
                self.ws = None
            return False

    async def call_command(self, command_type: str, **params) -> Dict[str, Any]:
        """
        Send a command and wait for response.

        Args:
            command_type: WebSocket command type (e.g., "lovelace/dashboards/list")
            **params: Additional command parameters

        Returns:
            Dict with command result
        """
        async with self._lock:
            if not self.ws or self.ws.closed:
                if not await self.connect():
                    raise Exception("Failed to establish WebSocket connection")

            # Generate unique message ID
            msg_id = self.msg_id
            self.msg_id += 1

            # Build command message
            command = {
                "id": msg_id,
                "type": command_type,
                **params
            }

            logger.info(f"WebSocket command: {command_type} (id={msg_id})")

            # Send command
            await self.ws.send(json.dumps(command))

            # Wait for response with matching ID
            while True:
                response_raw = await self.ws.recv()
                response = json.loads(response_raw)

                # Check if this is our response
                if response.get("id") == msg_id:
                    if response.get("type") == "result":
                        if response.get("success"):
                            logger.info(f"‚úÖ WebSocket command succeeded (id={msg_id})")
                            return response.get("result", {})
                        else:
                            error = response.get("error", {})
                            logger.error(f"‚ùå WebSocket command failed: {error}")
                            raise Exception(f"WebSocket error: {error.get('message', 'Unknown error')}")
                    else:
                        # Unexpected response type
                        raise Exception(f"Unexpected response type: {response.get('type')}")

    async def close(self):
        """Close WebSocket connection"""
        if self.ws:
            await self.ws.close()
            self.ws = None
            logger.info("WebSocket connection closed")


# Global WebSocket client instance (lazy initialization)
_ws_client: Optional[HomeAssistantWebSocket] = None

async def get_ws_client() -> HomeAssistantWebSocket:
    """Get or create WebSocket client instance"""
    global _ws_client
    if _ws_client is None:
        _ws_client = HomeAssistantWebSocket(HA_URL, HA_TOKEN)
    return _ws_client
```

**Key Features:**

- ‚úÖ Automatic authentication
- ‚úÖ Message ID tracking
- ‚úÖ Thread-safe with async lock
- ‚úÖ Auto-reconnect on disconnect
- ‚úÖ Comprehensive error handling

---

### Phase 3: Update Dashboard Tools (2-3 hours)

#### Step 3.1: List Dashboards

**Before (REST - Returns 404):**

```python
@app.post("/ha_list_dashboards")
async def ha_list_dashboards():
    response = await http_client.get(f"{HA_URL}/lovelace/dashboards")
    # ‚ùå Returns 404 - endpoint doesn't exist
```

**After (WebSocket - Works!):**

```python
@app.post("/ha_list_dashboards", operation_id="ha_list_dashboards", summary="List all Lovelace dashboards", tags=["dashboards"])
async def ha_list_dashboards():
    """
    List all Lovelace dashboards via WebSocket API.

    WebSocket command: {"type": "lovelace/dashboards/list"}

    Returns:
        List of dashboards with: url_path, title, icon, show_in_sidebar, require_admin
    """
    try:
        ws = await get_ws_client()
        dashboards = await ws.call_command("lovelace/dashboards/list")

        return SuccessResponse(
            message=f"Found {len(dashboards)} dashboards via WebSocket",
            data={
                "dashboards": dashboards,
                "count": len(dashboards),
                "source": "WebSocket API"
            }
        )
    except Exception as e:
        logger.error(f"Error listing dashboards: {e}", exc_info=True)
        raise HTTPException(status_code=500, detail=str(e))
```

#### Step 3.2: Get Dashboard Config

```python
@app.post("/ha_get_dashboard_config", operation_id="ha_get_dashboard_config", summary="Get dashboard configuration", tags=["dashboards"])
async def ha_get_dashboard_config(request: GetDashboardConfigRequest = Body(...)):
    """
    Get Lovelace dashboard configuration via WebSocket.

    WebSocket command: {"type": "lovelace/config", "url_path": "lovelace"}

    Args:
        url_path: Dashboard URL path (default: "lovelace")

    Returns:
        Full dashboard configuration (views, cards, etc.)
    """
    try:
        ws = await get_ws_client()
        config = await ws.call_command(
            "lovelace/config",
            url_path=request.url_path or "lovelace"
        )

        return SuccessResponse(
            message=f"Dashboard config retrieved: {request.url_path}",
            data={
                "url_path": request.url_path,
                "config": config,
                "views_count": len(config.get("views", [])),
                "source": "WebSocket API"
            }
        )
    except Exception as e:
        logger.error(f"Error getting dashboard config: {e}", exc_info=True)
        raise HTTPException(status_code=500, detail=str(e))
```

#### Step 3.3: Update Dashboard Config

```python
@app.post("/ha_update_dashboard_config", operation_id="ha_update_dashboard_config", summary="Update dashboard configuration", tags=["dashboards"])
async def ha_update_dashboard_config(request: UpdateDashboardConfigRequest = Body(...)):
    """
    Update Lovelace dashboard configuration via WebSocket.

    WebSocket command: {"type": "lovelace/config/save", "config": {...}}

    Args:
        url_path: Dashboard URL path
        config: New dashboard configuration (views, cards, etc.)

    IMPORTANT: This overwrites the entire dashboard config!
    """
    try:
        ws = await get_ws_client()
        result = await ws.call_command(
            "lovelace/config/save",
            url_path=request.url_path or "lovelace",
            config=request.config
        )

        return SuccessResponse(
            message=f"Dashboard config updated: {request.url_path}",
            data={
                "url_path": request.url_path,
                "updated": True,
                "source": "WebSocket API"
            }
        )
    except Exception as e:
        logger.error(f"Error updating dashboard config: {e}", exc_info=True)
        raise HTTPException(status_code=500, detail=str(e))
```

#### Step 3.4: Create Dashboard

```python
@app.post("/ha_create_dashboard", operation_id="ha_create_dashboard", summary="Create new dashboard", tags=["dashboards"])
async def ha_create_dashboard(request: CreateDashboardRequest = Body(...)):
    """
    Create a new Lovelace dashboard via WebSocket.

    WebSocket command: {"type": "lovelace/dashboards/create", ...}

    Args:
        url_path: Dashboard URL (must be unique)
        title: Dashboard title
        icon: Dashboard icon (e.g., "mdi:home")
        show_in_sidebar: Show in sidebar (default: true)
        require_admin: Require admin access (default: false)
    """
    try:
        ws = await get_ws_client()
        result = await ws.call_command(
            "lovelace/dashboards/create",
            url_path=request.url_path,
            title=request.title,
            icon=request.icon or "mdi:view-dashboard",
            show_in_sidebar=request.show_in_sidebar if request.show_in_sidebar is not None else True,
            require_admin=request.require_admin or False
        )

        return SuccessResponse(
            message=f"Dashboard created: {request.title}",
            data={
                "url_path": request.url_path,
                "title": request.title,
                "created": True,
                "source": "WebSocket API"
            }
        )
    except Exception as e:
        logger.error(f"Error creating dashboard: {e}", exc_info=True)
        raise HTTPException(status_code=500, detail=str(e))
```

#### Step 3.5: Delete Dashboard

```python
@app.post("/ha_delete_dashboard", operation_id="ha_delete_dashboard", summary="Delete dashboard", tags=["dashboards"])
async def ha_delete_dashboard(request: DeleteDashboardRequest = Body(...)):
    """
    Delete a Lovelace dashboard via WebSocket.

    WebSocket command: {"type": "lovelace/dashboards/delete", "url_path": "..."}

    Args:
        url_path: Dashboard URL path to delete

    WARNING: This permanently deletes the dashboard!
    """
    try:
        ws = await get_ws_client()
        result = await ws.call_command(
            "lovelace/dashboards/delete",
            url_path=request.url_path
        )

        return SuccessResponse(
            message=f"Dashboard deleted: {request.url_path}",
            data={
                "url_path": request.url_path,
                "deleted": True,
                "source": "WebSocket API"
            }
        )
    except Exception as e:
        logger.error(f"Error deleting dashboard: {e}", exc_info=True)
        raise HTTPException(status_code=500, detail=str(e))
```

#### Step 3.6-3.10: Card Creation Tools

For the 5 card creation tools (`ha_list_hacs_cards`, `ha_create_button_card`, etc.):

- These will likely still need REST or file-based approaches
- HACS card listing might use `lovelace/resources` WebSocket command
- Card creation will update the dashboard config via WebSocket

**Example for listing HACS cards:**

```python
@app.post("/ha_list_hacs_cards", operation_id="ha_list_hacs_cards", summary="List HACS custom cards", tags=["dashboards"])
async def ha_list_hacs_cards():
    """List installed HACS custom cards via WebSocket"""
    try:
        ws = await get_ws_client()
        resources = await ws.call_command("lovelace/resources")

        # Filter for custom cards
        hacs_cards = [r for r in resources if "hacs" in r.get("url", "").lower()]

        return SuccessResponse(
            message=f"Found {len(hacs_cards)} HACS cards",
            data={
                "cards": hacs_cards,
                "count": len(hacs_cards),
                "source": "WebSocket API"
            }
        )
    except Exception as e:
        logger.error(f"Error listing HACS cards: {e}", exc_info=True)
        raise HTTPException(status_code=500, detail=str(e))
```

---

### Phase 4: Testing (1 hour)

#### Test 4.1: WebSocket Connection Test

```powershell
# Test WebSocket authentication
POST http://192.168.1.203:8001/ha_list_dashboards
Expected: List of dashboards, no 404 error
```

#### Test 4.2: Dashboard Operations

```powershell
# Test 1: List dashboards
$result = Invoke-RestMethod -Uri "http://192.168.1.203:8001/ha_list_dashboards" -Method POST
Write-Host "Dashboards: $($result.data.count)"

# Test 2: Get config
$body = @{ url_path = "lovelace" } | ConvertTo-Json
$config = Invoke-RestMethod -Uri "http://192.168.1.203:8001/ha_get_dashboard_config" -Method POST -Body $body -ContentType "application/json"
Write-Host "Views: $($config.data.views_count)"

# Test 3: Create test dashboard
$body = @{
    url_path = "test-dashboard"
    title = "Test Dashboard"
    icon = "mdi:test-tube"
} | ConvertTo-Json
$create = Invoke-RestMethod -Uri "http://192.168.1.203:8001/ha_create_dashboard" -Method POST -Body $body -ContentType "application/json"
Write-Host "Created: $($create.message)"

# Test 4: Delete test dashboard
$body = @{ url_path = "test-dashboard" } | ConvertTo-Json
$delete = Invoke-RestMethod -Uri "http://192.168.1.203:8001/ha_delete_dashboard" -Method POST -Body $body -ContentType "application/json"
Write-Host "Deleted: $($delete.message)"
```

#### Test 4.3: Verify All Tools

```powershell
# Run comprehensive test
python test_all_endpoints.py

# Expected: 95/95 tools working (100%)
```

---

### Phase 5: Documentation & Deployment (30 minutes)

#### Step 5.1: Update CHANGELOG

```python
v4.0.7 (2025-11-08):
  üéâ MILESTONE: 100% tool success rate achieved!
  ‚úÖ WEBSOCKET: Implemented WebSocket client for dashboard operations
  ‚úÖ FIXED: All 10 dashboard/Lovelace tools now working
  üÜï NEW: Real-time WebSocket communication with HA
  üéØ Result: 95/95 tools working (was 85/95)
  üéØ Result: No more 404 errors on dashboard operations
  üéØ Result: Full Lovelace dashboard management via API
```

#### Step 5.2: Update Version Numbers

```python
# server.py header
Version: 4.0.7

# Health endpoint
"version": "4.0.7"

# Logger
logger.info("üöÄ Starting Home Assistant OpenAPI Server v4.0.7")
```

#### Step 5.3: Deploy to Production

```powershell
cd C:\MyProjects\ha-openapi-server-v3.0.0\v4.0.5
.\AUTO-DEPLOY.ps1

# Verify
$health = Invoke-RestMethod -Uri "http://192.168.1.203:8001/health"
Write-Host "Version: $($health.version)"  # Should show 4.0.7
Write-Host "Endpoints: $($health.endpoints)"  # Should show 95
```

---

## üß™ Testing Checklist

### Pre-Deployment Tests

- [ ] WebSocket connection establishes successfully
- [ ] WebSocket authentication works with SUPERVISOR_TOKEN
- [ ] Message ID tracking works correctly
- [ ] Error handling catches WebSocket failures gracefully
- [ ] Reconnection works after connection loss

### Dashboard Tool Tests

- [ ] `ha_list_dashboards` - Returns dashboard list
- [ ] `ha_get_dashboard_config` - Returns config JSON
- [ ] `ha_create_dashboard` - Creates new dashboard
- [ ] `ha_update_dashboard_config` - Updates config
- [ ] `ha_delete_dashboard` - Deletes dashboard

### Card Tool Tests

- [ ] `ha_list_hacs_cards` - Returns HACS card list
- [ ] `ha_create_button_card` - Creates button card config
- [ ] `ha_create_mushroom_card` - Creates mushroom card config
- [ ] `ha_manual_create_custom_card` - Creates custom YAML
- [ ] `ha_manual_edit_custom_card` - Edits custom YAML

### Integration Tests

- [ ] All 95 tools return success (100%)
- [ ] No 404 errors
- [ ] No authentication failures
- [ ] Performance acceptable (< 2s response time)
- [ ] Memory usage stable

---

## üìö Reference Documentation

### Official HA WebSocket API Docs

**URL:** https://developers.home-assistant.io/docs/api/websocket  
**Last Updated:** October 14, 2025

### WebSocket Commands for Dashboards

```javascript
// List dashboards
{"type": "lovelace/dashboards/list"}

// Get dashboard config
{"type": "lovelace/config", "url_path": "lovelace"}

// Save dashboard config
{
  "type": "lovelace/config/save",
  "url_path": "lovelace",
  "config": {
    "views": [...]
  }
}

// Create dashboard
{
  "type": "lovelace/dashboards/create",
  "url_path": "my-dashboard",
  "title": "My Dashboard",
  "icon": "mdi:home",
  "show_in_sidebar": true,
  "require_admin": false
}

// Delete dashboard
{
  "type": "lovelace/dashboards/delete",
  "url_path": "my-dashboard"
}

// List resources (for HACS cards)
{"type": "lovelace/resources"}
```

### WebSocket Message Flow

```
Client ‚Üí Server: Connect to ws://host:8123/api/websocket
Server ‚Üí Client: {"type": "auth_required", "ha_version": "..."}
Client ‚Üí Server: {"type": "auth", "access_token": "..."}
Server ‚Üí Client: {"type": "auth_ok", "ha_version": "..."}

Client ‚Üí Server: {"id": 1, "type": "lovelace/dashboards/list"}
Server ‚Üí Client: {"id": 1, "type": "result", "success": true, "result": [...]}
```

---

## ‚ö†Ô∏è Known Issues & Solutions

### Issue 1: WebSocket Timeout

**Problem:** WebSocket connection times out after inactivity  
**Solution:** Implement ping/pong keepalive (already in code: `ping_interval=20`)

### Issue 2: Token Expiration

**Problem:** SUPERVISOR_TOKEN might expire  
**Solution:** Use long-lived access token or refresh on 401 error

### Issue 3: Dashboard Lock

**Problem:** Dashboard locked while editing in UI  
**Solution:** Check for `config_mode_id` in error and notify user

### Issue 4: Concurrent Modifications

**Problem:** Multiple clients editing same dashboard  
**Solution:** Implement optimistic locking with version checks

---

## üéØ Success Metrics

### Definition of Done

- ‚úÖ WebSocket client implemented and tested
- ‚úÖ All 10 dashboard tools working (no 404s)
- ‚úÖ 95/95 tools success rate (100%)
- ‚úÖ Comprehensive error handling
- ‚úÖ Documentation updated
- ‚úÖ Deployed to production
- ‚úÖ Verified in Open-WebUI

### Performance Targets

- WebSocket connection: < 1s
- Dashboard list: < 500ms
- Config retrieval: < 1s
- Config update: < 2s
- Memory overhead: < 50MB

---

## üöÄ Bonus Features (If Time Permits)

### Bonus 1: Real-Time Event Subscription

```python
@app.post("/ha_subscribe_events")
async def ha_subscribe_events(event_type: str):
    """
    Subscribe to real-time HA events via WebSocket.
    Returns SSE stream for live updates.
    """
    ws = await get_ws_client()
    await ws.call_command("subscribe_events", event_type=event_type)
    # Stream events back to client
```

### Bonus 2: Automation Validation

```python
@app.post("/ha_validate_automation")
async def ha_validate_automation(automation: Dict):
    """
    Validate automation configuration via WebSocket.
    Uses: {"type": "validate_config", "trigger": [...]}
    """
    ws = await get_ws_client()
    result = await ws.call_command("validate_config", **automation)
    return {"valid": result.get("valid"), "errors": result.get("errors")}
```

### Bonus 3: Panel Management

```python
@app.post("/ha_get_panels")
async def ha_get_panels():
    """Get all HA panels via WebSocket"""
    ws = await get_ws_client()
    panels = await ws.call_command("get_panels")
    return {"panels": panels}
```

---

## üìù Post-Deployment Tasks

### Immediate (Day 1)

1. ‚úÖ Test all dashboard tools in Open-WebUI
2. ‚úÖ Monitor logs for WebSocket errors
3. ‚úÖ Verify memory/CPU usage
4. ‚úÖ Update README with WebSocket capabilities

### Short-term (Week 1)

1. üìä Create dashboard usage analytics
2. üìö Document common dashboard patterns
3. üéì Create tutorial for dashboard API usage
4. üîç Monitor for edge cases

### Long-term (Month 1)

1. üöÄ Implement event streaming
2. üé® Add dashboard templates
3. üîÑ Auto-backup dashboard configs
4. üìà Performance optimization

---

## üéì Learning Resources

### WebSocket Basics

- **Python websockets library:** https://websockets.readthedocs.io/
- **HA WebSocket API:** https://developers.home-assistant.io/docs/api/websocket
- **WebSocket debugging:** Use browser DevTools Network tab

### Dashboard Structure

- **Lovelace YAML reference:** https://www.home-assistant.io/dashboards/
- **Card types:** https://www.home-assistant.io/dashboards/cards/
- **HACS cards:** https://hacs.xyz/

---

## ‚úÖ Tomorrow's Timeline

**Time Estimate:** 4-6 hours total

| Time     | Task                           | Duration | Status |
| -------- | ------------------------------ | -------- | ------ |
| 9:00 AM  | Review plan & setup            | 30 min   | ‚è≥     |
| 9:30 AM  | Implement WebSocket client     | 1.5 hrs  | ‚è≥     |
| 11:00 AM | Update dashboard tools (1-5)   | 1 hr     | ‚è≥     |
| 12:00 PM | Lunch break                    | 30 min   | ‚è≥     |
| 12:30 PM | Update card tools (6-10)       | 1 hr     | ‚è≥     |
| 1:30 PM  | Testing & debugging            | 1 hr     | ‚è≥     |
| 2:30 PM  | Documentation                  | 30 min   | ‚è≥     |
| 3:00 PM  | Deployment                     | 30 min   | ‚è≥     |
| 3:30 PM  | Verification & celebration! üéâ | 30 min   | ‚è≥     |

**Total:** 6 hours (with breaks)

---

## üéâ Expected Outcome

**Before v4.0.7:**

```
Total Tools: 95
Working: 85 (89%)
Dashboard Tools: 0/10 working (404 errors)
```

**After v4.0.7:**

```
Total Tools: 95
Working: 95 (100%) ‚ú®
Dashboard Tools: 10/10 working (WebSocket)
üèÜ MILESTONE ACHIEVED: 100% Success Rate!
```

---

**Plan Created:** November 7, 2025  
**Execution Date:** November 8, 2025  
**Status:** Ready to implement üöÄ

**Next Step:** Get a good night's sleep and tackle this tomorrow! üí™
